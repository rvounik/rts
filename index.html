<!DOCTYPE html>
<html lang="en">
<head>
    <title>RTS 2</title>
    <style>
        body {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            font-size: 16px;
        }

        .wrapper {
            width: auto;
            max-width: 850px;
            margin: auto;
        }
        @media screen and (min-width: 1024px) {
            .wrapper {
                width: 850px;
                max-width: unset;
            }
        }
        .canvas-container {
            height: auto;
            max-height: 850px;
            width: 100%;
            box-sizing: border-box;
            border: 0;
            margin-top: 0;
            background: #000;
            box-shadow: none;
        }
        @media screen and (min-width: 1024px) {
            .canvas-container {
                margin-top: 20px;
                display: inline-block;
                box-sizing: content-box;
            }
        }
        canvas {
            image-rendering: optimizeSpeed;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: -o-crisp-edges;
            image-rendering: pixelated;
            -ms-interpolation-mode: nearest-neighbor;
        }
        #canvas {
            width: 100%;
            max-width: 850px;
            box-sizing: border-box;
            display: block;
            margin: 0 auto;
            background: #000;
        }
    </style>
</head>
<body>

<div class="wrapper">
    <div class="canvas-container" id="canvas-container">
        <canvas id="canvas" width="850" height="650">Oh no! Canvas is not supported on your device :(</canvas>
    </div>
</div>

<audio id="music-level-1" src="assets/music-level-1.mp3" preload="auto" loop></audio>
<audio id="tank" src="assets/tank.wav" preload="auto"></audio>

<script type="text/javascript" src="pathfinding-browser.min.js"></script>

<script>
    // register global window event listener for click events
    window.addEventListener('click', clickHandler);
    window.addEventListener('mousemove', hoverHandler);

    // declare some vars
    var context = document.getElementById('canvas').getContext('2d');

    // define tile map for scenery (always have 1's surrounding the 'playfield'; 6 vertically, 8 horizontally)
    var map = [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 5, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 2, 5, 1, 1, 1, 5, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 2, 5, 1, 5, 5, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 2, 5, 1, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 2, 5, 1, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 2, 5, 1, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 2, 5, 1, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 2, 5, 1, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 2, 5, 1, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 2, 2, 2, 2, 2, 2, 2, 2, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 2, 5, 6, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 5, 5, 5, 5, 2, 2, 2, 2, 2, 2, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 2, 5, 1, 5, 5, 2, 2, 2, 2, 2, 2, 2, 5, 5, 5, 5, 5, 5, 5, 5, 2, 2, 2, 2, 2, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 5, 5, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1, 1, 1, 5, 5, 5, 2, 2, 5, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 1, 1, 1, 1, 1, 5, 5, 5, 5, 5, 1, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ];

    var tempArray = [];
    var shadowMapX;
    var shadowMapY;

    var playerShadowMap = [];
    for (shadowMapY = 0; shadowMapY < map.length; shadowMapY ++) {
        tempArray = [];
        for (shadowMapX = 0; shadowMapX < map[0].length; shadowMapX ++) {
            tempArray.push(0);
        }
        playerShadowMap.push(tempArray);
    }

    var enemyShadowMap = [];
    for (shadowMapY = 0; shadowMapY < map.length; shadowMapY ++){
        tempArray = [];
        for (shadowMapX = 0; shadowMapX < map[0].length; shadowMapX ++) {
            tempArray.push(0);
        }
        enemyShadowMap.push(tempArray);
    }

    // define image assets todo: rename
    var bitmaps = [
        {
            id: 'grass',
            src: 'assets/tile-grass.png',
            img: new Image()
        },
        {
            id: 'water-1',
            src: 'assets/tile-water.png',
            img: new Image()
        },
        {
            id: 'water-2',
            src: 'assets/tile-water-2.png',
            img: new Image()
        },
        {
            id: 'tank',
            src: 'assets/tile-tank.png',
            img: new Image()
        },
        {
            id: 'tree',
            src: 'assets/tile-tree.png',
            img: new Image()
        },
        {
            id: 'sand',
            src: 'assets/tile-sand.png',
            img: new Image()
        },
        {
            id: 'bridge',
            src: 'assets/tile-bridge.png',
            img: new Image()
        },
        {
            id: 'tank-enemy',
            src: 'assets/tile-tank-enemy.png',
            img: new Image()
        },
        {
            id: 'tank-shot',
            src: 'assets/tile-tank-shot.png',
            img: new Image()
        },
        {
            id: 'rock',
            src: 'assets/tile-rock.png',
            img: new Image()
        }
    ];

    // call the loadBitmap function for each defined bitmap
    bitmaps.map(bitmap => {
       loadBitmap(bitmap);
    });

    // collection of objects describing all units in the game
    // 1000 > own units
    // 2000 > enemy units
    var units = [
        {
            id: 1001,
            unitType: 4,
            x: 450,
            y: 450,
            rotation: 90,
            gridX: 9,
            gridY: 9,
            gridDestX: null,
            gridDestY: null,
            gridSubDestX: null,
            gridSubDestY: null,
            path: [],
            target: null,
            speed: 5,
            health: 100,
            range: 3,
            rate: 2,
            damage: 20,
            rateTimer: 0,
            destinationTimeout: 0
        },
        {
            id: 1002,
            unitType: 4,
            x: 450,
            y: 500,
            rotation: 90,
            gridX: 9,
            gridY: 10,
            gridDestX: null,
            gridDestY: null,
            gridSubDestX: null,
            gridSubDestY: null,
            path: [],
            target: null,
            speed: 5,
            health: 100,
            range: 3,
            rate: 2,
            damage: 20,
            rateTimer: 0,
            destinationTimeout: 0
        },
        {
            id: 2001,
            unitType: 7,
            x: 750,
            y: 450,
            rotation: 0,
            gridX: 15,
            gridY: 9,
            gridDestX: 32,
            gridDestY: 9,
            gridSubDestX: null,
            gridSubDestY: null,
            path: [],
            target: null,
            speed: 5,
            health: 100,
            range: 4,
            destinationTimeout: 0
        },
        {
            id: 2002,
            unitType: 7,
            x: 450,
            y: 750,
            rotation: 0,
            gridX: 9,
            gridY: 15,
            gridDestX: 28,
            gridDestY: 9,
            gridSubDestX: null,
            gridSubDestY: null,
            path: [],
            target: null,
            speed: 5,
            health: 100,
            range: 4,
            destinationTimeout: 0
        },
        {
            id: 2003,
            unitType: 7,
            x: 500,
            y: 650,
            rotation: 0,
            gridX: 10,
            gridY: 13,
            gridDestX: null,
            gridDestY: null,
            gridSubDestX: null,
            gridSubDestY: null,
            path: [],
            target: null,
            speed: 5,
            health: 100,
            range: 4,
            destinationTimeout: 0
        },
        {
            id: 100,
            unitType: 100,
            x: 850,
            y: 450,
            gridX: 17,
            gridY: 9,
            health: 100
        },
        {
            id: 101,
            unitType: 100,
            x: 900,
            y: 450,
            gridX: 18,
            gridY: 9,
            health: 100
        },
        {
            id: 102,
            unitType: 100,
            x: 850,
            y: 500,
            gridX: 17,
            gridY: 10,
            health: 100
        },
        {
            id: 103,
            unitType: 101,
            x: 1650,
            y: 700,
            gridX: 33,
            gridY: 14,
            health: 100
        },
        {
            id: 104,
            unitType: 101,
            x: 1650,
            y: 750,
            gridX: 33,
            gridY: 15,
            health: 100
        },
        {
            id: 105,
            unitType: 101,
            x: 1600,
            y: 750,
            gridX: 32,
            gridY: 15,
            health: 100
        },
        {
            id: 105,
            unitType: 101,
            x: 1550,
            y: 750,
            gridX: 30,
            gridY: 15,
            health: 100
        }
    ];

    // loop through units to fill shadowmaps initially
    for (var unitI = 0; unitI < units.length; unitI ++) {
        updateShadowMapForUnit(units[unitI]);
    }

    // keeps track of units selected by the user. much faster than querying units array.
    var selectedUnits = [];

    // determines how many tiles visible on screen, max offset from edge, and starting position of map.
    var rangeX = 8;
    var rangeY = 6;

    // map start position (do not make it lower than rangeX, rangeY or higher than array size - range)
    var posX = 8;
    var posY = 6;

    // dimensions of tile
    tileWidth = 50;
    tileHeight = 50;

    // facilitates edge scrolling
    var edgeScrollingTimer = 0;
    var edgeScrolling = false;
    var edgeScrollingFlag = false; // keeps track of active edgeScrolling to prevent view being aligned with unit
    var scrollDirX = 0;
    var scrollDirY = 0;

    // facilitates water variation
    var waterVariationTimer = 0;

    // determines timeout for the frame showing a unit shooting
    var shotFrameTimeout = 0.5;

    // some runtime parameters
    var autoCenter = false;
    var soundEffects = true;

    var assetsLoaded = false;
    var loadingAsset;

    // create empty grid
    var grid = createPathfindingGrid();
    var finder = new PF.AStarFinder();

    // trigger update function
    updateCanvas();
    //updateEdgeScroller();

    /***************************** functions *******************************/

    function loadBitmap(bitmap) {
        // load the image assets by setting bitmap.img.src to bitmap.src
        bitmap['img'].src = bitmap['src']
    }

    function areAllImageAssetsLoaded() {
        for (var loadedBitmap = 0; loadedBitmap < bitmaps.length; loadedBitmap ++) {
            if (bitmaps[loadedBitmap] && bitmaps[loadedBitmap].img.naturalWidth > 0) {
            } else {
                loadingAsset = bitmaps[loadedBitmap].src;
                return false;
            }
        }

        return true;
    }

    function clickHandler(event) {
        // todo: handler does not take scaling into account

        // make sure only the canvas is targeted
        var offsetLeft = document.getElementById("canvas").offsetLeft;
        var offsetTop = document.getElementById("canvas").offsetTop;

        // get coordinates relative to grid
        var mouseX = event.clientX - offsetLeft;
        var mouseY = event.clientY - offsetTop;

        // ensure user clicked within bounds
        if (mouseX < 0 || mouseX > 850 || mouseY < 0 || mouseY > 650) {
            console.log('out of bounds');
        } else {
            // get value of grid that is at that position
            var gridX = Math.floor(mouseX / tileWidth);
            var gridY = Math.floor(mouseY / tileHeight);

            var newX, newY;

            // depending on whether player clicked right, left, up or down from center, calculate new map index
            if (gridX > rangeX) {
                newX = posX + (gridX - rangeX);
            } else {
                newX = posX - (rangeX - gridX);
            }
            if (gridY > rangeY) {
                newY = posY + (gridY - rangeY);
            } else {
                newY = posY - (rangeY - gridY);
            }

            // see if a unit lives at that position
            if (!grid.isWalkableAt(newX, newY)){
                // something is there. is it a unit?
                var unit = findInUnitsByGridCoordinates(newX, newY);

                if (unit) {
                    if (unit.id >= 2000){
                        // it is an enemy unit
                        setTargetForSelectedUnitsToId(unit.id);

                        // deselect all units
                        selectedUnits = [];
                    } else {
                        // it is your own unit
                        if (!findInSelectedUnitsById(unit.id)) {
                            // deselect all units
                            selectedUnits = [];

                            // was not selected, so select it
                            selectedUnits.push(unit.id);
                            edgeScrollingFlag = false;
                        } else {
                            // deselect all units
                            selectedUnits = [];
                            edgeScrollingFlag = false;
                        }

                    }
                } else {
                    // not a unit. move map.
                    setNewMapCoordinates(newX, newY);
                }

            } else {
                // this tile is walkable. so either move a selected unit there, or move the map selection
                // if a unit was already selected, set its target coordinates to the newX, newY
                if (map[newY][newX] !== 1 && selectedUnits.length > 0) {
                    // move selected units
                    for (var a = 0; a < selectedUnits.length; a++) {
                        var selectedUnitId = selectedUnits[a];
                        // console.log('moving unit '+selectedUnitId+' to coordinates '+newX+','+newY+' which has id '+map[newY][newX]);
                        moveUnitToPosition(selectedUnitId, newX, newY);
                        // clear all targets of selected units
                        // clearing targets
                        for (var ownUnit = 0; ownUnit < selectedUnits.length; ownUnit ++) {
                            findUnitById(selectedUnits[ownUnit]).target = null;
                        }
                        // deselect the unit (this seems UI-wise to be best)
                        selectedUnits = [];
                    }
                } else {
                    // move the view to the new location
                    setNewMapCoordinates(newX, newY);
                }
            }

        }
    }

    function hoverHandler(event) {
        // make sure only the canvas is targeted
        var offsetLeft = document.getElementById("canvas").offsetLeft;
        var offsetTop = document.getElementById("canvas").offsetTop;

        // get coordinates relative to grid
        var mouseX = event.clientX - offsetLeft;
        var mouseY = event.clientY - offsetTop;

        if ((mouseY > 650 ) || (mouseX > 850) || (mouseX < 0 || (mouseX > 25 && mouseX < 825)) && (mouseY < 0 || (mouseY > 25 && mouseY < 625))) {
            edgeScrolling = false;
        } else {
            edgeScrolling = true;
            edgeScrollingFlag = true;
            scrollDirX = 0;
            scrollDirY = 0;
            if (mouseY < 25 && mouseX > 825){scrollDirX++;scrollDirY--}
            else if (mouseY > 625 && mouseX > 825){scrollDirX++;scrollDirY++}
            else if (mouseY < 25 && mouseX < 25){scrollDirX--;scrollDirY--}
            else if (mouseY > 625 && mouseX < 25){scrollDirX--;scrollDirY++}
            else if (mouseX > 825){scrollDirX++}
            else if (mouseX < 25){scrollDirX--}
            else if (mouseY > 625){scrollDirY++}
            else if (mouseY < 25){scrollDirY--}
        }
    }

    function setTargetForSelectedUnitsToId(id){
        for (var unitToHaveTarget = 0; unitToHaveTarget < selectedUnits.length; unitToHaveTarget ++) {
            findUnitById(selectedUnits[unitToHaveTarget]).target = id;
        }
    }

    function setNewMapCoordinates(x, y) {
        posX = x;
        posY = y;

        // magic corrections (determines how much the map is allowed to move out of view. 8 for x, 6 for y)
        // todo: refactor to use rangeX, rangeY units
        if (posX < rangeX) {
            posX = rangeX
        }
        if (posX > (map[0].length - 9)) {
            posX = (map[0].length - 9)
        }
        if (posY < rangeY) {
            posY = rangeY
        }
        if (posY > (map.length - 7)) {
            posY = (map.length - 7)
        }
    }

    function createPathfindingGrid() {
        grid = new PF.Grid(map[0].length, map.length);

        // scenery (static)
        for (var a = 0; a < map.length; a ++){
            for (var b = 0; b < map[a].length; b ++){
                if (map[a][b] === 1) {
                    // found non-walkable tile
                    grid.setWalkableAt(b, a, false);
                }
            }
        }

        // units (including their sub destination grid coordinates)
        for (var c = 0;c < units.length; c ++) {
            // current unit grid position
            var x = units[c].gridX;
            var y = units[c].gridY;
            grid.setWalkableAt(x, y, false);
            // sub destination grid position
            if (units[c].gridSubDestX && units[c].gridSubDestY) {
                var x2 = units[c].gridSubDestX;
                var y2 = units[c].gridSubDestY;
                grid.setWalkableAt(x2, y2, false);
            }
        }

        return grid;
    }

    function findInSelectedUnitsById(id) {
        for (var selectedUnit = 0; selectedUnit < selectedUnits.length; selectedUnit ++){
            if (selectedUnits[selectedUnit] === id) {
                return true;
            }
        }

        return false;
    }

    function findInUnitsByGridCoordinates(x, y) {
        for (var unit = 0; unit < units.length; unit ++){
            if (x === units[unit].gridX && y === units[unit].gridY && units[unit].id >= 1000) {
                return units[unit];
            }
        }

        return false;
    }

    function drawMapSelection() {
        // draw all grid units that are within view
        for (var row = 0; row <= (2 * rangeY); row++) {
            var tileY = posY - rangeY; // range is -6 to 6 with 0 being middle or equal to posY
            tileY += row;
            for (var col = 0; col <= (2 * rangeX); col++) {
                var tileX = posX - rangeX;
                tileX += col;
                    var alpha = playerShadowMap[tileY][tileX];
                    drawBackgroundTile(col * tileWidth, row * tileHeight, map[tileY][tileX], alpha);
            }
        }
    }

    function getBitmapForTileType(tileType, state = null) {
        // if 'state' was provided, append that to the bitmap id. easy way to implement animation and alternative tiles
        switch (tileType){
            case 1: return findImageObjectInArrayById('water-1');
            case 2: return findImageObjectInArrayById('grass');
            case 100: return findImageObjectInArrayById('tree');
            case 101: return findImageObjectInArrayById('rock');
            case 4: return state === null ? findImageObjectInArrayById('tank') : findImageObjectInArrayById('tank-' + state);
            case 5: return findImageObjectInArrayById('sand');
            case 6: return findImageObjectInArrayById('bridge');
            case 7: return findImageObjectInArrayById('tank-enemy');
            case 8: return findImageObjectInArrayById('water-2');
            default: console.log('unknown tileType provided');return false;
        }
    }

    function findImageObjectInArrayById(id){
        for (var imageObject = 0; imageObject < bitmaps.length; imageObject ++){
            if (bitmaps[imageObject]['id'] === id) {
                return bitmaps[imageObject];
            }
        }
    }

    function findUnitById(id) {
        for (var unit = 0; unit < units.length; unit ++){
            if (units[unit]['id'] === id) {
                return units[unit];
            }
        }
    }

    function drawBackgroundTile(x, y, tileType, alpha) {
        var imageId = getBitmapForTileType(tileType);
        context.globalAlpha = alpha;
        context.drawImage(imageId['img'], x, y);
        context.globalAlpha = 1;
    }

    function moveUnitToPosition(unitId, newGridX, newGridY){
        // simply saves new grid position for a unit
        var unitToBeMoved = findUnitById(unitId);

        unitToBeMoved.gridDestX = newGridX;
        unitToBeMoved.gridDestY = newGridY;
    }

    function drawUnit(x, y, rotation = 0, unit, alpha) {
        var state = null;
        if (unit.rateTimer > unit.rate) {
            state = 'shot';
        }
        // note that the given x, y are already adjusted to fit the current view
        var imageId = getBitmapForTileType(unit.unitType, state);
        context.globalAlpha = alpha;
        context.save();
        context.translate(x + (tileWidth / 2), y + (tileHeight / 2)); // move canvas to spawn / pivoting position
        context.rotate(rotation * Math.PI / 180); // rotate to given value in radians
        context.drawImage(imageId['img'], 0 - (tileWidth / 2), 0 - (tileHeight / 2));
        context.restore();
        context.globalAlpha = 1;

        // selection caret
        context.strokeStyle = "#333";
        context.lineWidth = 2;
        if (findInSelectedUnitsById(unit.id)){context.strokeRect(x, y, tileWidth, tileHeight)}
    }

    function updateShadowMapForUnit(unit) {
        if (unit.id >= 1000 && unit.id < 2000){
            playerShadowMap[unit.gridY -3][unit.gridX] = (playerShadowMap[unit.gridY - 3][unit.gridX] === 1) ? 1 : .5;

            playerShadowMap[unit.gridY -2][unit.gridX - 1] = (playerShadowMap[unit.gridY - 2][unit.gridX - 1] === 1) ? 1 : .5;
            playerShadowMap[unit.gridY -2][unit.gridX] = 1;
            playerShadowMap[unit.gridY -2][unit.gridX + 1] = (playerShadowMap[unit.gridY - 2][unit.gridX + 1] === 1) ? 1 : .5;

            playerShadowMap[unit.gridY -1][unit.gridX - 2] = (playerShadowMap[unit.gridY - 1][unit.gridX - 2] === 1) ? 1 : .5;
            playerShadowMap[unit.gridY -1][unit.gridX - 1] = 1;
            playerShadowMap[unit.gridY -1][unit.gridX] = 1;
            playerShadowMap[unit.gridY -1][unit.gridX + 1] = 1;
            playerShadowMap[unit.gridY -1][unit.gridX + 2] = (playerShadowMap[unit.gridY - 1][unit.gridX + 2] === 1) ? 1 : .5;

            playerShadowMap[unit.gridY][unit.gridX - 3] = (playerShadowMap[unit.gridY][unit.gridX - 3] === 1) ? 1 : .5;
            playerShadowMap[unit.gridY][unit.gridX - 2] = 1;
            playerShadowMap[unit.gridY][unit.gridX - 1] = 1;
            playerShadowMap[unit.gridY][unit.gridX] = 1;
            playerShadowMap[unit.gridY][unit.gridX + 1] = 1;
            playerShadowMap[unit.gridY][unit.gridX + 2] = 1;
            playerShadowMap[unit.gridY][unit.gridX + 3] = (playerShadowMap[unit.gridY][unit.gridX + 3] === 1) ? 1 : .5;

            playerShadowMap[unit.gridY + 1][unit.gridX -2] = (playerShadowMap[unit.gridY + 1][unit.gridX - 2] === 1) ? 1 : .5;
            playerShadowMap[unit.gridY + 1][unit.gridX - 1] = 1;
            playerShadowMap[unit.gridY + 1][unit.gridX] = 1;
            playerShadowMap[unit.gridY + 1][unit.gridX + 1] = 1;
            playerShadowMap[unit.gridY + 1][unit.gridX + 2] = (playerShadowMap[unit.gridY + 1][unit.gridX + 2] === 1) ? 1 : .5;

            playerShadowMap[unit.gridY + 2][unit.gridX -1] = 1;
            playerShadowMap[unit.gridY + 2][unit.gridX] = 1;
            playerShadowMap[unit.gridY + 2][unit.gridX + 1] = 1;

            playerShadowMap[unit.gridY + 3][unit.gridX] = (playerShadowMap[unit.gridY + 3][unit.gridX] === 1) ? 1 : .5;

        } else if(unit.id > 2000) {
            // note there is no fancy opacity stuff going on here since its not visible
            enemyShadowMap[unit.gridY -3][unit.gridX] = 1;

            enemyShadowMap[unit.gridY -2][unit.gridX - 1] = 1;
            enemyShadowMap[unit.gridY -2][unit.gridX] = 1;
            enemyShadowMap[unit.gridY -2][unit.gridX + 1] = 1;

            enemyShadowMap[unit.gridY -1][unit.gridX - 2] = 1;
            enemyShadowMap[unit.gridY -1][unit.gridX - 1] = 1;
            enemyShadowMap[unit.gridY -1][unit.gridX] = 1;
            enemyShadowMap[unit.gridY -1][unit.gridX + 1] = 1;
            enemyShadowMap[unit.gridY -1][unit.gridX + 2] = 1;

            enemyShadowMap[unit.gridY][unit.gridX - 3] = 1;
            enemyShadowMap[unit.gridY][unit.gridX - 2] = 1;
            enemyShadowMap[unit.gridY][unit.gridX - 1] = 1;
            enemyShadowMap[unit.gridY][unit.gridX] = 1;
            enemyShadowMap[unit.gridY][unit.gridX + 1] = 1;
            enemyShadowMap[unit.gridY][unit.gridX + 2] = 1;
            enemyShadowMap[unit.gridY][unit.gridX + 3] = 1;

            enemyShadowMap[unit.gridY + 1][unit.gridX -2] = 1;
            enemyShadowMap[unit.gridY + 1][unit.gridX - 1] = 1;
            enemyShadowMap[unit.gridY + 1][unit.gridX] = 1;
            enemyShadowMap[unit.gridY + 1][unit.gridX + 1] = 1;
            enemyShadowMap[unit.gridY + 1][unit.gridX + 2] = 1;

            enemyShadowMap[unit.gridY + 2][unit.gridX -1] = 1;
            enemyShadowMap[unit.gridY + 2][unit.gridX] = 1;
            enemyShadowMap[unit.gridY + 2][unit.gridX + 1] = 1;

            enemyShadowMap[unit.gridY + 3][unit.gridX] = 1;
        }


    }

    function drawUnitsInMapSelection(){
        for (var a = 0; a < units.length; a ++){
            // calculate relative x,y
            var relX = units[a].x - ((posX - rangeX) * tileWidth);
            var relY = units[a].y - ((posY - rangeY) * tileHeight);
            var rotation = units[a].rotation;
            if (relX >= 0 && relX < 850 && relY >= 0 && relY < 650){
                // if in view, draw the unit
                var alpha = playerShadowMap[units[a].gridY][units[a].gridX];
                drawUnit(relX, relY, rotation, units[a], alpha);
            }
        }
    }

    function getPathForUnitPositions(x, y, newx, newy, target = false) {
        // you need to reinstantiate the grid for each call! see https://github.com/qiao/PathFinding.js/issues/109
        grid = createPathfindingGrid();

        // right before calculating the path, set the current grid position to walkable (otherwise path wont be calculated)
        grid.setWalkableAt(x, y, true);
        // if path is towards a target, set it walkable otherwise no path is calculated
        if (target){grid.setWalkableAt(newx, newy, true)}
        // calculate the path
        var pathOutput = finder.findPath(x, y, newx, newy, grid);
        // reset the grid positions that previously were marked walkable
        grid.setWalkableAt(x, y, false);
        if (target){grid.setWalkableAt(newx, newy, false)}

        // keep in mind, the path shouldnt end in the target's x,y, so pop that last entry off the path if moving towards a target
        if (target){pathOutput.pop()}

        return pathOutput;
    }

    function shootWithUnit(unit) {
        rotateUnitTowardsTheTarget(unit);

        // do the timer thingies for shooting
        unit.rateTimer += 0.1;

        if (unit.rateTimer > unit.rate) {
            // note that the changing of the tile to a 'shooting tile' is done by reading out rateTimer in drawUnit
            if (soundEffects) {
                document.getElementById('tank').play(); // todo: does not handle multiple instances playing
            }
            // ensure rateTimer eventually times out
            if (unit.rateTimer > (unit.rate + shotFrameTimeout)) {
                unit.rateTimer = 0;
            }
        }
    }

    function updateUnitCoordinates() {
        for (var c = 0; c < units.length; c ++) {
            var unit = units[c];
            var x = unit.x;
            var y = unit.y;

            // first, check if gridDestX,Y still matches the target's X,Y
            if (unit.target){
                var targetX = findUnitById(unit.target).gridX;
                var targetY = findUnitById(unit.target).gridY;
                if (unit.gridDestX !== targetX || unit.gridDestY !== targetY) {
                    // chasing target
                    unit.gridDestX = null;
                    unit.gridDestY = null;
                    unit.gridSubDestX = null;
                    unit.gridSubDestY = null;
                }
            }

            // is unit movable (id>1000) and does it have a grid destination?
            if (unit.id >= 1000 && unit.gridDestX && unit.gridDestY) {
                // is there a subtarget set?
                if (unit.gridSubDestX && unit.gridSubDestY) {
                    // is subtarget reached?
                    if (unit.gridX === unit.gridSubDestX && unit.gridY === unit.gridSubDestY) {
                        // console.log('reached sub destination ' + unit.gridSubDestX + ',' + unit.gridSubDestY);
                        unit.gridSubDestX = null;
                        unit.gridSubDestY = null;

                        updateShadowMapForUnit(unit);

                        // is final target reached?
                        if (unit.gridX === unit.gridDestX && unit.gridY === unit.gridDestY) {
                            // reached final destination
                            // console.log('reached final destination ' + unit.gridDestX + ',' + unit.gridDestY);
                            unit.path = [];
                            unit.gridSubDestX = null;
                            unit.gridSubDestY = null;
                            unit.gridDestX = null;
                            unit.gridDestY = null;
                        } else {
                            // recalculate path
                            var target = unit.target !== null; // if target is set, the gridDestX,Y are the grid of a unit which is normally not walkable thus calculation will fail unless we pass this parameter so it is set to walkable
                            unit.path = getPathForUnitPositions(unit.gridX, unit.gridY, unit.gridDestX, unit.gridDestY, target);

                            // within attack range?
                            if (unit.target !== null && unit.path.length < unit.range) {
                                // within reach (clear path and dest
                                unit.path = [];
                                unit.gridSubDestX = null;
                                unit.gridSubDestY = null;
                                unit.gridDestX = null;
                                unit.gridDestY = null;
                            } else if (unit.path.length >= 2) {
                                // take the first entry off the path (actually the second, first one is current position)
                                unit.gridSubDestX = unit.path[1][0];
                                unit.gridSubDestY = unit.path[1][1];
                            } else {
                                // path is blocked off by some other unit or incorrectly calculated (could be expensive!)
                                console.log('1. if you never see this (repeating), you can safely remove this else');
                            }
                        }
                    } else {
                        // not there yet. calculate translation for x, y (depending on orientation also)
                        unit.rateTimer = 0;
                        unit.destinationTimeout = 0;

                        if (unit.gridSubDestX < unit.gridX) {
                            x -= unit.speed;
                            unit.rotation = 270;
                            // ensure it doesnt move past its destination
                            if (x <= ((unit.gridX - 1) * tileWidth)) {
                                x = ((unit.gridX - 1) * tileWidth);
                                // just before changing grid position for this unit, update the grid with a walkable = true at the old position
                                grid.setWalkableAt(unit.gridX, unit.gridY, true);
                                unit.gridX --;
                                grid.setWalkableAt(unit.gridX, unit.gridY, false); // and reserve the new tile
                            }
                        }
                        else if (unit.gridSubDestX > unit.gridX) {
                            x += unit.speed;
                            unit.rotation = 90;
                            // ensure it doesnt move past its destination
                            if (x >= ((unit.gridX + 1) * tileWidth)) {
                                x = ((unit.gridX + 1) * tileWidth);
                                // just before changing grid position for this unit, update the grid with a walkable = true at the old position
                                grid.setWalkableAt(unit.gridX, unit.gridY, true);
                                unit.gridX ++;
                                grid.setWalkableAt(unit.gridX, unit.gridY, false); // and reserve the new tile
                            }
                        }
                        else if (unit.gridSubDestY < unit.gridY) {
                            y -= unit.speed;
                            unit.rotation = 0;
                            // ensure it doesnt move past its destination
                            if (y <= ((unit.gridY - 1) * tileWidth)) {
                                y = ((unit.gridY - 1) * tileHeight);
                                // just before changing grid position for this unit, update the grid with a walkable = true at the old position
                                grid.setWalkableAt(unit.gridX, unit.gridY, true);
                                unit.gridY --;
                                grid.setWalkableAt(unit.gridX, unit.gridY, false); // and reserve the new tile
                            }
                        }
                        else if (unit.gridSubDestY > unit.gridY) {
                            y += unit.speed;
                            unit.rotation = 180;
                            // ensure it doesnt move past its destination
                            if (y >= ((unit.gridY + 1) * tileHeight)) {
                                y = ((unit.gridY + 1) * tileHeight);
                                // just before changing grid position for this unit, update the grid with a walkable = true at the old position
                                grid.setWalkableAt(unit.gridX, unit.gridY, true);
                                unit.gridY ++;
                                grid.setWalkableAt(unit.gridX, unit.gridY, false); // and reserve the new tile
                            }
                        }
                    }
                } else {
                    var targetFlag = (unit.target !== null); // if target is set, the gridDestX,Y are the grid of a unit which is normally not walkable thus calculation will fail unless we pass this parameter so it is set to walkable
                    unit.path = getPathForUnitPositions(unit.gridX, unit.gridY, unit.gridDestX, unit.gridDestY, targetFlag);

                    if(unit.target!==null){
                        if((unit.path.length < unit. range) || (unit.path.length <= 1)){
                            // erase the path, we can shoot from here
                            unit.path = [];
                            unit.gridSubDestX = null;
                            unit.gridSubDestY = null;
                            unit.gridDestX = null;
                            unit.gridDestY = null;
                            shootWithUnit(unit);
                        } else {
                            if (unit.path.length > 1) {
                                // there is room to move closer
                                unit.gridSubDestX = unit.path[1][0];
                                unit.gridSubDestY = unit.path[1][1];
                            } else {
                                console.log('2. if you never see this, you can safely remove this else')
                            }
                        }
                    } else {
                        // no target set, see if we can set a subdestination
                        if (unit.path.length > 1) {
                            // set next sub destination for this unit
                            unit.gridSubDestX = unit.path[1][0];
                            unit.gridSubDestY = unit.path[1][1];
                        } else {
                            // path blocked
                            unit.destinationTimeout ++;
                            if (unit.destinationTimeout > 250) {
                                // time out destination for unit
                                unit.gridSubDestX = null;
                                unit.gridSubDestY = null;
                                unit.gridDestX = null;
                                unit.gridDestY = null;
                                unit.target = null;
                                unit.destinationTimeout = 0;
                            }
                        }
                    }
                  }
                }
            else {
                // no gridDestX,Y set for this unit, does it have a target?
                if (unit.id >= 1000 && unit.target !== null) {
                    // it has a target, so set destination coordinates to coordinates of target
                    var targetUnit = findUnitById(unit.target);
                    unit.gridDestX = targetUnit.gridX;
                    unit.gridDestY = targetUnit.gridY;
                } else {
                    // no target, no grid destination, so.. guard mode
                }
            }

            // update x,y for this unit
            unit.x = x;
            unit.y = y;
        }
    }

    function rotateUnitTowardsTheTarget(unit) {
        // ensure unit is always pointed towards the target
        var targetUnit = findUnitById(unit.target);

        if (targetUnit.gridX < unit.gridX) {
            if (targetUnit.gridY < unit.gridY) {
                // up-left
                unit.rotation = 315;
            } else if (targetUnit.gridY > unit.gridY) {
                // down-left
                unit.rotation = 225;
            } else {
                // left
                unit.rotation = 270;
            }
        } else if (targetUnit.gridX > unit.gridX) {
            if (targetUnit.gridY < unit.gridY) {
                // up-right
                unit.rotation = 45;
            } else if (targetUnit.gridY > unit.gridY) {
                // down-right
                unit.rotation = 135;
            } else {
                // right
                unit.rotation = 90;
            }
        } else {
            // x = equal
            if (targetUnit.gridY < unit.gridY) {
                // up
                unit.rotation = 0;
            } else if (targetUnit.gridY > unit.gridY) {
                // down
                unit.rotation = 180;
            }
        }
    }

    function updateEdgeScroller() {
        if (edgeScrolling) {
            if (posX+scrollDirX > rangeX && posX+scrollDirX < (map[0].length - rangeX)) {posX += scrollDirX}
            if (posY+scrollDirY > rangeY && posY+scrollDirY < (map.length - rangeY)) {posY += scrollDirY}
        }
    }

    function updateCanvas() {
        clearCanvas();

        if (assetsLoaded) {
            // this is controlled by autoCenter flag. not sure if going to keep since it is not very smooth
            if (!edgeScrollingFlag && selectedUnits.length === 1) {
                // if a single unit is selected and the current view positions are different, update them (follow mode)
                if (posX !== findUnitById(selectedUnits[0]).gridX || posY !== findUnitById(selectedUnits[0]).gridY) {
                    edgeScrollingFlag = false;
                    if (autoCenter) {
                        posX = findUnitById(selectedUnits[0]).gridX;
                        posY = findUnitById(selectedUnits[0]).gridY;
                    }
                }
            }

            drawMapSelection();
            updateUnitCoordinates();
            drawUnitsInMapSelection();

            // edge scrolling and its timer
            if (Date.now() - 100 > edgeScrollingTimer) {
                edgeScrollingTimer = Date.now();
                if (edgeScrolling) {
                    updateEdgeScroller()
                }
            }

            if (Date.now() - 2000 > waterVariationTimer) {
                waterVariationTimer = Date.now();
                // looping through all 1 in the map and replacing some with 8. likewise, all existing 8 are back to 1 again
                for (var a = 0; a < map.length; a++) {
                    for (var b = 0; b < map[a].length; b++) {
                        if (map[a][b] === 8) {
                            map[a][b] = 1;
                        }
                        if (map[a][b] === 1 && (parseInt(Math.random() * 250) === 1)) {
                            map[a][b] = 8;
                        }
                    }
                }
            }
        } else {
            if (areAllImageAssetsLoaded()) {
                context.font = "30px Trebuchet MS";
                context.fillStyle = "#fff";
                context.fillText("LOADING", (850 / 2) - (context.measureText("LOADING").width / 2), 250);
                context.font = "14px Trebuchet MS";
                context.fillStyle = "#888";
                context.fillText("sound data", (850 / 2) - (context.measureText("sound data").width / 2), 280);
                if (document.getElementById('music-level-1').readyState) {
                    assetsLoaded = true;

                    if (soundEffects) {
                        document.getElementById('music-level-1').play();
                    }
                }
            } else {
                context.font = "30px Trebuchet MS";
                context.fillStyle = "#fff";
                context.fillText("LOADING", (850 / 2) - (context.measureText("LOADING").width / 2), 250);
                context.font = "14px Trebuchet MS";
                context.fillStyle = "#888";
                context.fillText(loadingAsset, (850 / 2) - (context.measureText(loadingAsset).width / 2), 280);
            }
        }

        // set interval
        setTimeout(updateCanvas, 50);
    }

    function clearCanvas() {
        context.fillStyle = '#000';
        context.fillRect(0, 0, 850, 650);
    }
</script>



</body>
</html>
