<!DOCTYPE html>
<html lang="en">
<head>
    <title>RTS 2</title>
    <style>
        body {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            font-size: 16px;
        }

        .wrapper {
            width: auto;
            max-width: 850px;
            margin: auto;
        }
        @media screen and (min-width: 1024px) {
            .wrapper {
                width: 850px;
                max-width: unset;
            }
        }
        .canvas-container {
            height: auto;
            max-height: 850px;
            width: 100%;
            box-sizing: border-box;
            border: 0;
            margin-top: 0;
            background: #000;
            box-shadow: none;
        }
        @media screen and (min-width: 1024px) {
            .canvas-container {
                margin-top: 20px;
                display: inline-block;
                box-sizing: content-box;
            }
        }
        canvas {
            image-rendering: optimizeSpeed;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: -o-crisp-edges;
            image-rendering: pixelated;
            -ms-interpolation-mode: nearest-neighbor;
        }
        #canvas {
            width: 100%;
            max-width: 850px;
            box-sizing: border-box;
            display: block;
            margin: 0 auto;
            background: #000;
        }
    </style>
</head>
<body>

<div class="wrapper">
    <div class="canvas-container" id="canvas-container">
        <canvas id="canvas" width="850" height="650">Oh no! Canvas is not supported on your device :(</canvas>
    </div>
</div>

<audio id="music-level-1" src="assets/music-level-1.mp3" preload="auto" loop></audio>

<script type="text/javascript" src="pathfinding-browser.min.js"></script>

<script>
    // register global window event listener for click events
    window.addEventListener('click', clickHandler);
    window.addEventListener('mousemove', hoverHandler);

    // declare some vars
    var context = document.getElementById('canvas').getContext('2d');

    // define tile map for scenery (always have 1's surrounding the 'playfield'; 6 vertically, 8 horizontally)
    var map = [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 5, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 2, 5, 1, 1, 1, 5, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 2, 5, 1, 5, 5, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 2, 5, 1, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 2, 5, 1, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 2, 5, 1, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 2, 5, 1, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 2, 5, 1, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 2, 5, 1, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 2, 2, 2, 2, 2, 2, 2, 2, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 2, 5, 6, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 5, 5, 5, 5, 2, 2, 2, 2, 2, 2, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 2, 5, 1, 5, 5, 2, 2, 2, 2, 2, 2, 2, 5, 5, 5, 5, 5, 5, 5, 5, 2, 2, 2, 2, 2, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 5, 5, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1, 1, 1, 5, 5, 5, 2, 2, 5, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 1, 1, 1, 1, 1, 5, 5, 5, 5, 5, 1, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ];

    var tempArray = [];
    var shadowMapX;
    var shadowMapY;

    var playerShadowMap = [];
    for (shadowMapY = 0; shadowMapY < map.length; shadowMapY ++) {
        tempArray = [];
        for (shadowMapX = 0; shadowMapX < map[0].length; shadowMapX ++) {
            tempArray.push(0);
        }
        playerShadowMap.push(tempArray);
    }

    var enemyShadowMap = [];
    for (shadowMapY = 0; shadowMapY < map.length; shadowMapY ++) {
        tempArray = [];
        for (shadowMapX = 0; shadowMapX < map[0].length; shadowMapX ++) {
            tempArray.push(0);
        }
        enemyShadowMap.push(tempArray);
    }

    // define image assets
    var images = [
        {
            id: 'grass',
            src: 'assets/tile-grass.png',
            img: new Image()
        },
        {
            id: 'water-1',
            src: 'assets/tile-water.png',
            img: new Image()
        },
        {
            id: 'water-2',
            src: 'assets/tile-water-2.png',
            img: new Image()
        },
        {
            id: 'tank',
            src: 'assets/tile-tank.png',
            img: new Image()
        },
        {
            id: 'tree',
            src: 'assets/tile-tree.png',
            img: new Image()
        },
        {
            id: 'sand',
            src: 'assets/tile-sand.png',
            img: new Image()
        },
        {
            id: 'bridge',
            src: 'assets/tile-bridge.png',
            img: new Image()
        },
        {
            id: 'tank-enemy',
            src: 'assets/tile-tank-enemy.png',
            img: new Image()
        },
        {
            id: 'tank-shot',
            src: 'assets/tile-tank-shot.png',
            img: new Image()
        },
        {
            id: 'tank-enemy-shot',
            src: 'assets/tile-tank-enemy-shot.png',
            img: new Image()
        },
        {
            id: 'rock',
            src: 'assets/tile-rock.png',
            img: new Image()
        }
    ];

    // call the loadImage function for each defined image
    images.map(image => {
       loadImage(image);
    });

    // collection of objects describing all units in the game (100 > scenery units, 1000 > own units, 2000 > enemy units)
    var units = [
        {
            id: 1001,
            unitType: 4,
            x: 450,
            y: 450,
            rotation: 90,
            gridX: 9,
            gridY: 9,
            gridDestX: null,
            gridDestY: null,
            gridSubDestX: null,
            gridSubDestY: null,
            path: [],
            target: null,
            speed: 6,
            health: 100,
            range: 3,
            rate: 2,
            damage: 20,
            rateTimer: 0,
            destinationTimeout: 0
        },
        {
            id: 1002,
            unitType: 4,
            x: 450,
            y: 500,
            rotation: 90,
            gridX: 9,
            gridY: 10,
            gridDestX: null,
            gridDestY: null,
            gridSubDestX: null,
            gridSubDestY: null,
            path: [],
            target: null,
            speed: 6,
            health: 100,
            range: 3,
            rate: 2,
            damage: 20,
            rateTimer: 0,
            destinationTimeout: 0
        },
        {
            id: 2001,
            unitType: 7,
            x: 750,
            y: 450,
            rotation: 0,
            gridX: 15,
            gridY: 9,
            gridDestX: null,
            gridDestY: null,
            gridSubDestX: null,
            gridSubDestY: null,
            path: [],
            target: null,
            speed: 4,
            health: 100,
            range: 3,
            rate: 2,
            damage: 5,
            rateTimer: 0,
            destinationTimeout: 0,
        },
        {
            id: 2002,
            unitType: 7,
            x: 450,
            y: 750,
            rotation: 0,
            gridX: 9,
            gridY: 15,
            gridDestX: null,
            gridDestY: null,
            gridSubDestX: null,
            gridSubDestY: null,
            path: [],
            target: null,
            speed: 4,
            health: 100,
            range: 3,
            rate: 2,
            damage: 5,
            rateTimer: 0,
            destinationTimeout: 0,
        },
        {
            id: 2003,
            unitType: 7,
            x: 500,
            y: 450,
            rotation: 0,
            gridX: 20,
            gridY: 6,
            gridDestX: null,
            gridDestY: null,
            gridSubDestX: null,
            gridSubDestY: null,
            path: [],
            target: null,
            speed: 4,
            health: 100,
            range: 3,
            rate: 2,
            damage: 5,
            rateTimer: 0,
            destinationTimeout: 0,
        },
        {
            id: 100,
            unitType: 100,
            x: 850,
            y: 450,
            gridX: 17,
            gridY: 9,
            health: 100,
        },
        {
            id: 101,
            unitType: 100,
            x: 900,
            y: 450,
            gridX: 18,
            gridY: 9,
            health: 100
        },
        {
            id: 102,
            unitType: 100,
            x: 850,
            y: 500,
            gridX: 17,
            gridY: 10,
            health: 100
        },
        {
            id: 103,
            unitType: 101,
            x: 1650,
            y: 700,
            gridX: 33,
            gridY: 14,
            health: 100
        },
        {
            id: 104,
            unitType: 101,
            x: 1650,
            y: 750,
            gridX: 33,
            gridY: 15,
            health: 100
        },
        {
            id: 105,
            unitType: 101,
            x: 1600,
            y: 750,
            gridX: 32,
            gridY: 15,
            health: 100
        },
        {
            id: 105,
            unitType: 101,
            x: 1550,
            y: 750,
            gridX: 31,
            gridY: 15,
            health: 100
        }
    ];

    // loop through units to fill shadowmaps initially
    for (var unitI = 0; unitI < units.length; unitI ++) {
        updateShadowMapForUnit(units[unitI]);
    }

    // keeps track of units selected by the user. much faster than querying units array.
    var selectedUnits = [];

    // determines how many tiles visible on screen, max offset from edge, and starting position of map.
    var rangeX = 8;
    var rangeY = 6;

    // map start position (do not make it lower than rangeX, rangeY or higher than array size - range)
    var posX = 12;
    var posY = 9;

    // dimensions of tile
    tileWidth = 50;
    tileHeight = 50;

    // facilitates edge scrolling
    var edgeScrollingTimer = 0;
    var edgeScrolling = false;
    var edgeScrollingFlag = false; // keeps track of active edgeScrolling to prevent view being aligned with unit
    var scrollDirX = 0;
    var scrollDirY = 0;

    // facilitates water variation
    var waterVariationTimer = 0;

    // determines timeout for the frame showing a unit shooting
    var shotFrameTimeout = 0.5;
    var shotsFired = false;

    // ensures spotted enemies are not spotted twice
    spottedEnemiesArray = [];

    // facilitates (pre)loading
    var assetsLoaded = false;
    var loadingAsset;

    // create empty grid
    var grid = createPathfindingGrid();
    var finder = new PF.DijkstraFinder();

    // some runtime parameters
    var autoCenter = false;
    var soundEffects = true;
    var debug = false;

    var enemyOffense = 0.5;
    var enemyDefense = 0.5;
    var enemyExploration = 0.9;
    var enemySpeedForCheckingUnits = 5000;
    var oldEnemyCheckTimer = 0;

    gameover = false;

    // trigger update function
    updateCanvas();

    /***************************** functions *******************************/

    function playSound(sound) {
        if (soundEffects) {
            var audio = new Audio();
            audio.src = sound;
            audio.play();
        }
    }

    function loadImage(image) {
        // load the image assets by setting image.img.src to image.src
        image['img'].src = image['src']
    }

    function areAllImageAssetsLoaded() {
        for (var loadedBitmap = 0; loadedBitmap < images.length; loadedBitmap ++) {
            if (images[loadedBitmap] && images[loadedBitmap].img.naturalWidth > 0) {
            } else {
                loadingAsset = images[loadedBitmap].src;
                return false;
            }
        }

        return true;
    }

    function clickHandler(event) {
        var scaleFactor = (850 / document.querySelector(".wrapper").offsetWidth);

        // make sure only the canvas is targeted
        var offsetLeft = (scaleFactor * document.getElementById("canvas").offsetLeft);
        var offsetTop = (scaleFactor * document.getElementById("canvas").offsetTop);

        // get coordinates relative to grid
        var mouseX = (scaleFactor * event.clientX - offsetLeft);
        var mouseY = (scaleFactor * event.clientY - offsetTop);

        // ensure user clicked within bounds
        if (mouseX < 0 || mouseX > (scaleFactor * 850) || mouseY < 0 || mouseY > (scaleFactor * 650)) {
            playSound('assets/sound-error.mp3');
            if (debug) {console.log('out of bounds')}
        } else {
            // get value of grid that is at that position
            var gridX = Math.floor(mouseX / tileWidth);
            var gridY = Math.floor(mouseY / tileHeight);

            var newX, newY;

            // depending on whether player clicked right, left, up or down from center, calculate new map index
            if (gridX > rangeX) {
                newX = posX + (gridX - rangeX);
            } else {
                newX = posX - (rangeX - gridX);
            }
            if (gridY > rangeY) {
                newY = posY + (gridY - rangeY);
            } else {
                newY = posY - (rangeY - gridY);
            }

            if (playerShadowMap[newY][newX] > 0) {
                if (debug) {console.log('tile visible')}
                if (map[newY][newX] !== 1) {
                    if (debug) {console.log('tile walkable')}
                    if (!grid.isWalkableAt(newX, newY)) {
                        if (debug) {console.log('tile contains unit')}
                        var unit = findInUnitsByGridCoordinates(newX, newY);
                        if (unit && unit.id < 1000) {
                            if (debug) {console.log('unit is scenery, moving map')}
                            setNewMapCoordinates(newX, newY);
                        }
                        if (unit && unit.id >= 1000 && unit.id < 2000) {
                            if (debug) {console.log('unit is own unit, deselecting all units, then selecting this one')}
                            if (selectedUnits.length > 0 && findInSelectedUnitsById(unit.id)) {
                                if (debug) {console.log('unit was already selected, deselecting')}
                                selectedUnits = [];
                            } else {
                                selectedUnits = [];
                                selectedUnits.push(unit.id);
                                edgeScrollingFlag = false;

                                var whichSound = parseInt(Math.random() * 2);
                                if (whichSound === 0) {
                                    playSound('assets/sound-yes.mp3')
                                }
                                if (whichSound === 1) {
                                    playSound('assets/sound-orders.mp3')
                                }
                            }
                        }
                        if (unit && unit.id >= 2000) {
                            if (debug) {console.log('unit is enemy unit')}
                            if (selectedUnits.length > 0) {
                                if (debug) {console.log('units are selected, setting attack targets, then deselecting')}
                                setTargetForSelectedUnitsToId(unit.id);
                                selectedUnits = [];
                                edgeScrollingFlag = false;
                            } else {
                                if (debug) {console.log('no units are selected, moving map')}
                                setNewMapCoordinates(newX, newY);
                            }
                        }
                    } else {
                        if (debug) {console.log('visible, walkable, no units')}
                        if (selectedUnits.length > 0) {
                            moveSelectedUnitsToPosition(newX, newY);
                        } else {
                            if (debug) {console.log('no units are selected, moving map')}
                            setNewMapCoordinates(newX, newY);
                        }
                    }
                } else {
                    if (debug) {console.log('tile not walkable, move map')}
                    setNewMapCoordinates(newX, newY);
                }
            } else {
                if (debug) {console.log('tile invisible')}
                if (selectedUnits.length > 0) {
                    if (debug) {console.log('units are selected. whether tile is walkable or contains a unit, whatever, move the unit(s) to the nearest spot')}
                    var nearestPath = findNearestPath(newX, newY);
                    if (nearestPath) {
                        var closestCoordinates = nearestPath[(nearestPath.length - 1)];
                        moveSelectedUnitsToPosition(closestCoordinates[0], closestCoordinates[1])
                    }
                } else {
                    if (debug) {console.log('no units are selected, thus just move the map to that position')}
                    setNewMapCoordinates(newX, newY);
                }
            }
        }
    }

    function findNearestPath(newX, newY) {
        // calculate the shortest path on a direct map (fully walkable) but with units present

        // assume only one unit is selected (later on this can be converted to a loop)
        var unitX = findUnitById(selectedUnits[0]).gridX;
        var unitY = findUnitById(selectedUnits[0]).gridY;

        // construct new grid
        var tempGrid = new PF.Grid(map[0].length, map.length);

        // deduct units (including their sub destination grid coordinates)
        for (var c = 0; c < units.length; c++) {
            // current unit grid position
            var x = units[c].gridX;
            var y = units[c].gridY;
            tempGrid.setWalkableAt(x, y, false);
            // sub destination grid position
            if (units[c].gridSubDestX && units[c].gridSubDestY) {
                var x2 = units[c].gridSubDestX;
                var y2 = units[c].gridSubDestY;
                tempGrid.setWalkableAt(x2, y2, false);
            }
        }

        if (!tempGrid.isWalkableAt(newX, newY)) {
            // set the requested unit walkable before calculating the path (or else it wont calculate a path)
            tempGrid.setWalkableAt(newX, newY, true);
            var directPath = finder.findPath(unitX, unitY, newX, newY, tempGrid);
            tempGrid.setWalkableAt(newX, newY, false);
            // pop the last one already, because that is the target tile, and it is not walkable in this case
            directPath.pop();
        } else {
            var directPath = finder.findPath(unitX, unitY, newX, newY, tempGrid);
        }

        // now start deducting the path until the last position is accessible according to map (units are already taken into account by the grid/path)
        while (map[(directPath[directPath.length - 1][1])][directPath[directPath.length - 1][0]] === 1) {
            directPath.pop();

            if (directPath.length === 1) {
                if (debug) {console.log('path exhausted')}
                playSound('assets/sound-error.mp3');
                return false;
            }
        }

        return directPath;
    }

    function moveSelectedUnitsToPosition(newX, newY) {
        if (map[newY][newX] !== 1) {
            // move selected units
            for (var a = 0; a < selectedUnits.length; a++) {
                var selectedUnitId = selectedUnits[a];
                if (debug) {console.log('moving unit '+selectedUnitId+' to coordinates '+newX+','+newY+' which has id '+map[newY][newX])}
                moveUnitToPosition(selectedUnitId, newX, newY);

                var whichSound = parseInt(Math.random() * 2);
                if (whichSound === 0) {playSound('assets/sound-moving.mp3')}
                if (whichSound === 1) {playSound('assets/sound-okay.mp3')}

                // clear all targets of selected units
                for (var ownUnit = 0; ownUnit < selectedUnits.length; ownUnit ++) {
                    findUnitById(selectedUnits[ownUnit]).target = null;
                }

                // deselect the unit (this seems UI-wise to be best)
                selectedUnits = [];
            }
        }
    }

    function hoverHandler(event) {
        var scaleFactor = (850 / document.querySelector(".wrapper").offsetWidth);

        // make sure only the canvas is targeted
        var offsetLeft = (scaleFactor * document.getElementById("canvas").offsetLeft);
        var offsetTop = (scaleFactor * document.getElementById("canvas").offsetTop);

        // get coordinates relative to grid
        var mouseX = (scaleFactor * event.clientX - offsetLeft);
        var mouseY = (scaleFactor * event.clientY - offsetTop);

        if ((mouseY > 650 ) || (mouseX > 850) || (mouseX < 0 || (mouseX > 25 && mouseX < 825)) && (mouseY < 0 || (mouseY > 25 && mouseY < 625))) {
            edgeScrolling = false;
        } else {
            edgeScrolling = true;
            edgeScrollingFlag = true;
            scrollDirX = 0;
            scrollDirY = 0;
            if (mouseY < 25 && mouseX > 825) {scrollDirX++;scrollDirY--}
            else if (mouseY > 625 && mouseX > 825) {scrollDirX++;scrollDirY++}
            else if (mouseY < 25 && mouseX < 25) {scrollDirX--;scrollDirY--}
            else if (mouseY > 625 && mouseX < 25) {scrollDirX--;scrollDirY++}
            else if (mouseX > 825) {scrollDirX++}
            else if (mouseX < 25) {scrollDirX--}
            else if (mouseY > 625) {scrollDirY++}
            else if (mouseY < 25) {scrollDirY--}
        }
    }

    function setTargetForSelectedUnitsToId(id) {
        if (selectedUnits.length > 0) {
            if (findUnitById(id).gridDestX !== null || findUnitById(id).gridDestY !== null) {
                playSound('assets/sound-inpursuit.mp3');
            } else {
                playSound('assets/sound-attacking.mp3');
            }

            for (var unitToHaveTarget = 0; unitToHaveTarget < selectedUnits.length; unitToHaveTarget ++) {
                findUnitById(selectedUnits[unitToHaveTarget]).target = id;
            }
        }
    }

    function setNewMapCoordinates(newX, newY) {
        posX = newX;
        posY = newY;

        // magic corrections (determines how much the map is allowed to move out of view. 8 for x, 6 for y)
        if (posX < rangeX) {posX = rangeX}
        if (posX >= (map[0].length - rangeX)) {posX = (map[0].length - (rangeX + 1))}
        if (posY < rangeY) {posY = rangeY}
        if (posY >= (map.length - rangeY)) {posY = (map.length - (rangeY + 1))}
    }

    function createPathfindingGrid() {
        grid = new PF.Grid(map[0].length, map.length);

        // scenery (static)
        for (var a = 0; a < map.length; a ++) {
            for (var b = 0; b < map[a].length; b ++) {
                if (map[a][b] === 1) {
                    // found non-walkable tile
                    grid.setWalkableAt(b, a, false);
                }
            }
        }

        // units (including their sub destination grid coordinates)
        for (var c = 0;c < units.length; c ++) {
            // current unit grid position
            var x = units[c].gridX;
            var y = units[c].gridY;
            grid.setWalkableAt(x, y, false);
            // sub destination grid position
            if (units[c].gridSubDestX && units[c].gridSubDestY) {
                var x2 = units[c].gridSubDestX;
                var y2 = units[c].gridSubDestY;
                grid.setWalkableAt(x2, y2, false);
            }
        }

        return grid;
    }

    function findInSelectedUnitsById(id) {
        return (selectedUnits.includes(id));
    }

    function findInUnitsByGridCoordinates(gridX, gridY) {
        for (var unit = 0; unit < units.length; unit ++) {
            if (gridX === units[unit].gridX && gridY === units[unit].gridY && units[unit].id >= 0) {
                return units[unit];
            }
        }

        return false;
    }

    function drawMapSelection() {
        // draw all grid units that are within view
        for (var row = 0; row <= (2 * rangeY); row++) {
            var tileY = posY - rangeY; // range is -6 to 6 with 0 being middle or equal to posY
            tileY += row;
            for (var col = 0; col <= (2 * rangeX); col++) {
                var tileX = posX - rangeX;
                tileX += col;
                    var alpha = playerShadowMap[tileY][tileX];
                    drawBackgroundTile(col * tileWidth, row * tileHeight, map[tileY][tileX], alpha);
            }
        }
    }

    function getBitmapForTileType(tileType, state = null) {
        // if 'state' was provided, append that to the bitmap id. easy way to implement animation and alternative tiles
        switch (tileType) {
            case 1: return findImageObjectInArrayById('water-1');
            case 2: return findImageObjectInArrayById('grass');
            case 4: return state === null ? findImageObjectInArrayById('tank') : findImageObjectInArrayById('tank-' + state);
            case 5: return findImageObjectInArrayById('sand');
            case 6: return findImageObjectInArrayById('bridge');
            case 7: return state === null ? findImageObjectInArrayById('tank-enemy') : findImageObjectInArrayById('tank-enemy-' + state);
            case 8: return findImageObjectInArrayById('water-2');
            case 100: return findImageObjectInArrayById('tree');
            case 101: return findImageObjectInArrayById('rock');
            default: if (debug) {console.log('unknown tileType provided')} return false;
        }
    }

    function findImageObjectInArrayById(id) {
        for (var imageObject = 0; imageObject < images.length; imageObject ++) {
            if (images[imageObject]['id'] === id) {
                return images[imageObject];
            }
        }
    }

    function findUnitById(id) {
        for (var unit = 0; unit < units.length; unit ++) {
            if (units[unit]['id'] === id) {
                return units[unit];
            }
        }
    }

    function drawBackgroundTile(x, y, tileType, alpha) {
        var imageId = getBitmapForTileType(tileType);
        context.globalAlpha = alpha;
        context.drawImage(imageId['img'], x, y);
        context.globalAlpha = 1;
    }

    function moveUnitToPosition(unitId, newGridX, newGridY) {
        // simply saves new grid position for a unit
        var unitToBeMoved = findUnitById(unitId);

        unitToBeMoved.gridDestX = newGridX;
        unitToBeMoved.gridDestY = newGridY;
    }

    function drawUnit(x, y, rotation = 0, unit, alpha) {
        var state = null;
        if (unit.rateTimer > unit.rate) {
            state = 'shot';
        }
        // note that the given x, y are already adjusted to fit the current view
        var imageId = getBitmapForTileType(unit.unitType, state);
        context.save();
        context.globalAlpha = alpha;
        context.translate(x + (tileWidth / 2), y + (tileHeight / 2)); // move canvas to spawn / pivoting position
        context.rotate(rotation * Math.PI / 180); // rotate to given value in radians
        context.drawImage(imageId['img'], 0 - (tileWidth / 2), 0 - (tileHeight / 2));
        context.restore();

        // selection caret
        context.strokeStyle = "#333";
        context.lineWidth = 2;
        if (findInSelectedUnitsById(unit.id)) {
            context.strokeRect(x, y, tileWidth, tileHeight)
        }
    }

    function updateShadowMapForUnit(unit) {
        if (unit.id >= 1000 && unit.id < 2000) {
            playerShadowMap[unit.gridY -3][unit.gridX] = (playerShadowMap[unit.gridY - 3][unit.gridX] === 1) ? 1 : .5;
            playerShadowMap[unit.gridY -2][unit.gridX - 1] = (playerShadowMap[unit.gridY - 2][unit.gridX - 1] === 1) ? 1 : .5;
            playerShadowMap[unit.gridY -2][unit.gridX] = 1;
            playerShadowMap[unit.gridY -2][unit.gridX + 1] = (playerShadowMap[unit.gridY - 2][unit.gridX + 1] === 1) ? 1 : .5;
            playerShadowMap[unit.gridY -1][unit.gridX - 2] = (playerShadowMap[unit.gridY - 1][unit.gridX - 2] === 1) ? 1 : .5;
            playerShadowMap[unit.gridY -1][unit.gridX - 1] = 1;
            playerShadowMap[unit.gridY -1][unit.gridX] = 1;
            playerShadowMap[unit.gridY -1][unit.gridX + 1] = 1;
            playerShadowMap[unit.gridY -1][unit.gridX + 2] = (playerShadowMap[unit.gridY - 1][unit.gridX + 2] === 1) ? 1 : .5;
            playerShadowMap[unit.gridY][unit.gridX - 3] = (playerShadowMap[unit.gridY][unit.gridX - 3] === 1) ? 1 : .5;
            playerShadowMap[unit.gridY][unit.gridX - 2] = 1;
            playerShadowMap[unit.gridY][unit.gridX - 1] = 1;
            playerShadowMap[unit.gridY][unit.gridX] = 1;
            playerShadowMap[unit.gridY][unit.gridX + 1] = 1;
            playerShadowMap[unit.gridY][unit.gridX + 2] = 1;
            playerShadowMap[unit.gridY][unit.gridX + 3] = (playerShadowMap[unit.gridY][unit.gridX + 3] === 1) ? 1 : .5;
            playerShadowMap[unit.gridY + 1][unit.gridX -2] = (playerShadowMap[unit.gridY + 1][unit.gridX - 2] === 1) ? 1 : .5;
            playerShadowMap[unit.gridY + 1][unit.gridX - 1] = 1;
            playerShadowMap[unit.gridY + 1][unit.gridX] = 1;
            playerShadowMap[unit.gridY + 1][unit.gridX + 1] = 1;
            playerShadowMap[unit.gridY + 1][unit.gridX + 2] = (playerShadowMap[unit.gridY + 1][unit.gridX + 2] === 1) ? 1 : .5;
            playerShadowMap[unit.gridY + 2][unit.gridX -1] = (playerShadowMap[unit.gridY + 2][unit.gridX -1] === 1) ? 1 : .5;
            playerShadowMap[unit.gridY + 2][unit.gridX] = 1;
            playerShadowMap[unit.gridY + 2][unit.gridX + 1] = (playerShadowMap[unit.gridY + 2][unit.gridX +1] === 1) ? 1 : .5;
            playerShadowMap[unit.gridY + 3][unit.gridX] = (playerShadowMap[unit.gridY + 3][unit.gridX] === 1) ? 1 : .5;
        } else if (unit.id > 2000) {
            // note there is no fancy opacity stuff going on here since its not visible
            enemyShadowMap[unit.gridY -3][unit.gridX] = 1;
            enemyShadowMap[unit.gridY -2][unit.gridX - 1] = 1;
            enemyShadowMap[unit.gridY -2][unit.gridX] = 1;
            enemyShadowMap[unit.gridY -2][unit.gridX + 1] = 1;
            enemyShadowMap[unit.gridY -1][unit.gridX - 2] = 1;
            enemyShadowMap[unit.gridY -1][unit.gridX - 1] = 1;
            enemyShadowMap[unit.gridY -1][unit.gridX] = 1;
            enemyShadowMap[unit.gridY -1][unit.gridX + 1] = 1;
            enemyShadowMap[unit.gridY -1][unit.gridX + 2] = 1;
            enemyShadowMap[unit.gridY][unit.gridX - 3] = 1;
            enemyShadowMap[unit.gridY][unit.gridX - 2] = 1;
            enemyShadowMap[unit.gridY][unit.gridX - 1] = 1;
            enemyShadowMap[unit.gridY][unit.gridX] = 1;
            enemyShadowMap[unit.gridY][unit.gridX + 1] = 1;
            enemyShadowMap[unit.gridY][unit.gridX + 2] = 1;
            enemyShadowMap[unit.gridY][unit.gridX + 3] = 1;
            enemyShadowMap[unit.gridY + 1][unit.gridX -2] = 1;
            enemyShadowMap[unit.gridY + 1][unit.gridX - 1] = 1;
            enemyShadowMap[unit.gridY + 1][unit.gridX] = 1;
            enemyShadowMap[unit.gridY + 1][unit.gridX + 1] = 1;
            enemyShadowMap[unit.gridY + 1][unit.gridX + 2] = 1;
            enemyShadowMap[unit.gridY + 2][unit.gridX -1] = 1;
            enemyShadowMap[unit.gridY + 2][unit.gridX] = 1;
            enemyShadowMap[unit.gridY + 2][unit.gridX + 1] = 1;
            enemyShadowMap[unit.gridY + 3][unit.gridX] = 1;
        }
    }

    function findInSpottedEnemiesArray(unitId) {
        return (spottedEnemiesArray.includes(unitId))
    }

    function drawUnitsInMapSelection() {
        for (var a = 0; a < units.length; a ++) {
            // calculate relative x,y
            var relX = units[a].x - ((posX - rangeX) * tileWidth);
            var relY = units[a].y - ((posY - rangeY) * tileHeight);
            var rotation = units[a].rotation;
            if (relX >= 0 && relX < 850 && relY >= 0 && relY < 650) {
                // if in view, draw the unit
                var alpha = playerShadowMap[units[a].gridY][units[a].gridX];
                drawUnit(relX, relY, rotation, units[a], alpha);
            }
        }
    }

    function getPathForUnitPositions(gridX, gridY, newX, newY, target = false) {
        // you need to reinstantiate the grid for each call! see https://github.com/qiao/PathFinding.js/issues/109
        grid = createPathfindingGrid();

        // right before calculating the path, set the current grid position to walkable (otherwise path wont be calculated)
        grid.setWalkableAt(gridX, gridY, true);
        // if path is towards a target, set it walkable otherwise no path is calculated
        if (target) {grid.setWalkableAt(newX, newY, true)}
        // calculate the path
        var pathOutput = finder.findPath(gridX, gridY, newX, newY, grid);
        // reset the grid positions that previously were marked walkable
        grid.setWalkableAt(gridX, gridY, false);
        if (target) {grid.setWalkableAt(newX, newY, false)}

        // keep in mind, the path should not end in the target's x,y. pop last entry off the path if moving towards a target
        if (target) {pathOutput.pop()}

        return pathOutput;
    }

    function shootWithUnit(unit) {
        rotateUnitTowardsTheTarget(unit);

        // do the timer thingies for shooting
        unit.rateTimer += 0.1;

        if (unit.rateTimer > unit.rate) {
            // note that the changing of the tile to a 'shooting tile' is done by reading out rateTimer in drawUnit
            if (soundEffects && !shotsFired) {
                playSound('assets/sound-shot.mp3');
                findUnitById(unit.target).health -= unit.damage;
                if (findUnitById(unit.target).health <= 0) {

                    if (unit.id >= 2000) {
                        // enemy attacks a player unit
                        var totalPlayerUnits = 0;

                        for (var a = 0; a < units.length; a++) {
                            if (units[a].id === unit.target) {
                                if (debug) {
                                    console.log('found a destroyed unit, removing from array')
                                }
                                units.splice(a, 1);
                                a--; // since array is shortened, that will screw up the iteration. this corrects it.

                                unit.rateTimer = 0;
                                shotsFired = false;
                            } else {
                                if (units[a].id >= 1000 && units[a].id < 2000) {
                                    totalPlayerUnits++;
                                }
                            }
                        }

                        if (totalPlayerUnits === 0) {
                            playSound('assets/sound-gameover.mp3');
                            console.log('game over');
                            gameover = true;
                        } else {
                            if (unit.id >= 1000 && unit.id < 2000) {
                                playSound('assets/sound-unitlost.mp3');
                            }
                        }
                    } else if (unit.id >= 1000 && unit.id < 2000) {
                        // player attacks an enemy unit
                        var totalEnemyUnits = 0;

                        for (var a = 0; a < units.length; a++) {
                            if (units[a].id === unit.target) {
                                if (debug) {
                                    console.log('found a destroyed unit, removing from array')
                                }
                                units.splice(a, 1);
                                a--; // since array is shortened, that will screw up the iteration. this corrects it.

                                unit.rateTimer = 0;
                                shotsFired = false;
                            } else {
                                if (units[a].id >= 2000) {
                                    totalEnemyUnits++;
                                }
                            }
                        }

                        if (totalEnemyUnits === 0) {
                            playSound('assets/sound-victory.mp3');
                            console.log('YOU HAVE WON');
                            gameover = true;
                        } else {
                            if (unit.id >= 1000 && unit.id < 2000) {
                                // todo: add enemy unit destroyed sound instead
                                playSound('assets/sound-unitlost.mp3');
                            }
                        }
                    }





                } else {
                    shotsFired = true;
                }

            }
            // ensure rateTimer eventually times out
            if (unit.rateTimer > (unit.rate + shotFrameTimeout)) {
                unit.rateTimer = 0;
                shotsFired = false;
            }
        }
    }

    function updateUnitCoordinates() {
        for (var c = 0; c < units.length; c ++) {
            var unit = units[c];
            var x = unit.x;
            var y = unit.y;

            // is unit movable (id>1000) and does it have a grid destination?
            if (unit.id >= 1000 && unit.gridDestX && unit.gridDestY) {
                // is there a subtarget set?
                if (unit.gridSubDestX && unit.gridSubDestY) {
                    // is subtarget reached?
                    if (unit.gridX === unit.gridSubDestX && unit.gridY === unit.gridSubDestY) {
                        if (debug) {console.log('reached sub destination ' + unit.gridSubDestX + ',' + unit.gridSubDestY)}
                        unit.gridSubDestX = null;
                        unit.gridSubDestY = null;

                        updateShadowMapForUnit(unit);

                        // is final target reached?
                        if (unit.gridX === unit.gridDestX && unit.gridY === unit.gridDestY) {
                            // reached final destination
                            //if (debug) {console.log('reached final destination ' + unit.gridDestX + ',' + unit.gridDestY)}
                            unit.path = [];
                            unit.gridSubDestX = null;
                            unit.gridSubDestY = null;
                            unit.gridDestX = null;
                            unit.gridDestY = null;
                        } else {
                            // recalculate path
                            var target = unit.target !== null; // if target is set, the gridDestX,Y are the grid of a unit which is normally not walkable thus calculation will fail unless we pass this parameter so it is set to walkable
                            unit.path = getPathForUnitPositions(unit.gridX, unit.gridY, unit.gridDestX, unit.gridDestY, target);

                            // within attack range?
                            if (unit.target !== null && unit.path.length < unit.range) {
                                // within reach (clear path and dest
                                unit.path = [];
                                unit.gridSubDestX = null;
                                unit.gridSubDestY = null;
                                unit.gridDestX = null;
                                unit.gridDestY = null;
                            } else if (unit.path.length >= 2) {
                                // take the first entry off the path (actually the second, first one is current position)
                                unit.gridSubDestX = unit.path[1][0];
                                unit.gridSubDestY = unit.path[1][1];
                            } else {
                                // path is blocked off by some other unit or incorrectly calculated
                                if (debug) {console.log('path is blocked for unit '+unit.id)}
                            }
                        }
                    } else {
                        // not there yet. calculate translation for x, y (depending on orientation also)
                        unit.rateTimer = 0;
                        unit.destinationTimeout = 0;

                        if (unit.gridSubDestX < unit.gridX) {
                            x -= unit.speed;
                            unit.rotation = 270;
                            // ensure it doesnt move past its destination
                            if (x <= ((unit.gridX - 1) * tileWidth)) {
                                x = ((unit.gridX - 1) * tileWidth);
                                // just before changing grid position for this unit, update the grid with a walkable = true at the old position
                                grid.setWalkableAt(unit.gridX, unit.gridY, true);
                                unit.gridX --;
                                grid.setWalkableAt(unit.gridX, unit.gridY, false); // and reserve the new tile
                            }
                        }
                        else if (unit.gridSubDestX > unit.gridX) {
                            x += unit.speed;
                            unit.rotation = 90;
                            // ensure it doesnt move past its destination
                            if (x >= ((unit.gridX + 1) * tileWidth)) {
                                x = ((unit.gridX + 1) * tileWidth);
                                // just before changing grid position for this unit, update the grid with a walkable = true at the old position
                                grid.setWalkableAt(unit.gridX, unit.gridY, true);
                                unit.gridX ++;
                                grid.setWalkableAt(unit.gridX, unit.gridY, false); // and reserve the new tile
                            }
                        }
                        else if (unit.gridSubDestY < unit.gridY) {
                            y -= unit.speed;
                            unit.rotation = 0;
                            // ensure it doesnt move past its destination
                            if (y <= ((unit.gridY - 1) * tileWidth)) {
                                y = ((unit.gridY - 1) * tileHeight);
                                // just before changing grid position for this unit, update the grid with a walkable = true at the old position
                                grid.setWalkableAt(unit.gridX, unit.gridY, true);
                                unit.gridY --;
                                grid.setWalkableAt(unit.gridX, unit.gridY, false); // and reserve the new tile
                            }
                        }
                        else if (unit.gridSubDestY > unit.gridY) {
                            y += unit.speed;
                            unit.rotation = 180;
                            // ensure it doesnt move past its destination
                            if (y >= ((unit.gridY + 1) * tileHeight)) {
                                y = ((unit.gridY + 1) * tileHeight);
                                // just before changing grid position for this unit, update the grid with a walkable = true at the old position
                                grid.setWalkableAt(unit.gridX, unit.gridY, true);
                                unit.gridY ++;
                                grid.setWalkableAt(unit.gridX, unit.gridY, false); // and reserve the new tile
                            }
                        }
                    }
                } else {
                    if (unit.target && unit.target !== null  && !findUnitById(unit.target)) {
                        if (debug) {console.log('cant find the targeted unit. was probably destroyed')}
                        unit.target = null;
                    }

                    var targetFlag = (unit.target !== null); // if target is set, the gridDestX,Y are the grid of a unit which is normally not walkable thus calculation will fail unless we pass this parameter so it is set to walkable
                    unit.path = getPathForUnitPositions(unit.gridX, unit.gridY, unit.gridDestX, unit.gridDestY, targetFlag);

                    if (unit.target !== null) {
                        if ((unit.path.length < unit. range) || (unit.path.length <= 1)) {
                            // erase the path, we can shoot from here
                            unit.path = [];
                            unit.gridSubDestX = null;
                            unit.gridSubDestY = null;
                            unit.gridDestX = null;
                            unit.gridDestY = null;

                            shootWithUnit(unit);
                        } else {
                            if (unit.path.length > 1) {
                                // there is room to move closer
                                unit.gridSubDestX = unit.path[1][0];
                                unit.gridSubDestY = unit.path[1][1];
                            } else {
                                console.log('if you see this, run for cover!')
                            }
                        }
                    } else {
                        // no target set, see if we can set a subdestination
                        if (unit.path.length > 1) {
                            // set next sub destination for this unit
                            unit.gridSubDestX = unit.path[1][0];
                            unit.gridSubDestY = unit.path[1][1];
                        } else {
                            // path blocked
                            unit.destinationTimeout ++;
                            if (unit.destinationTimeout > 250) {
                                // time out destination for unit
                                unit.gridSubDestX = null;
                                unit.gridSubDestY = null;
                                unit.gridDestX = null;
                                unit.gridDestY = null;
                                unit.target = null;
                                unit.destinationTimeout = 0;
                            }
                        }
                    }
                  }
                }
            else {
                if (unit.target && unit.target !== null  && !findUnitById(unit.target)) {
                    if (debug) {console.log('cant find the targeted unit. was probably destroyed')}
                    unit.target = null;
                }

                // no gridDestX,Y set for this unit, does it have a target?
                if (unit.id >= 1000 && unit.target !== null) {
                    // it has a target, so set destination coordinates to coordinates of target
                    var targetUnit = findUnitById(unit.target);
                    unit.gridDestX = targetUnit.gridX;
                    unit.gridDestY = targetUnit.gridY;
                } else {
                    // no target, no grid destination, so.. guard mode
                }

            }

            // update x,y for this unit
            unit.x = x;
            unit.y = y;
        }
    }

    function rotateUnitTowardsTheTarget(unit) {
        if (unit.target && unit.target !== null  && !findUnitById(unit.target)) {
            if (debug) {console.log('cant find the targeted unit. was probably destroyed')}
            unit.target = null;
        }
        // ensure unit is always pointed towards the target
        var targetUnit = findUnitById(unit.target);

        if (targetUnit.gridX < unit.gridX) {
            if (targetUnit.gridY < unit.gridY) {
                // up-left
                unit.rotation = 315;
            } else if (targetUnit.gridY > unit.gridY) {
                // down-left
                unit.rotation = 225;
            } else {
                // left
                unit.rotation = 270;
            }
        } else if (targetUnit.gridX > unit.gridX) {
            if (targetUnit.gridY < unit.gridY) {
                // up-right
                unit.rotation = 45;
            } else if (targetUnit.gridY > unit.gridY) {
                // down-right
                unit.rotation = 135;
            } else {
                // right
                unit.rotation = 90;
            }
        } else {
            // x = equal
            if (targetUnit.gridY < unit.gridY) {
                // up
                unit.rotation = 0;
            } else if (targetUnit.gridY > unit.gridY) {
                // down
                unit.rotation = 180;
            }
        }
    }

    function updateSpottedEnemies() {
        for (var a = 0; a < playerShadowMap.length; a ++) {
            for (var b = 0; b < playerShadowMap[a].length; b ++) {
                if (playerShadowMap[a][b] > 0) {
                    var spottedEnemy = findInUnitsByGridCoordinates(b, a);
                    if (!gameover && spottedEnemy && spottedEnemy.id >= 2000 && !findInSpottedEnemiesArray(spottedEnemy.id)){
                        spottedEnemiesArray.push(spottedEnemy.id);
                        playSound('assets/sound-enemyspotted.mp3');
                    }
                }
            }
        }
    }

    function getAllVisibleTargets() {
        var possibleTargets = [];

        for (var a = 0; a < enemyShadowMap.length; a ++) {
            for (var b = 0; b < enemyShadowMap[a].length; b ++) {
                if (enemyShadowMap[a][b] > 0) {
                    var unit = findInUnitsByGridCoordinates(b, a);
                    if (unit && unit.id >= 1000 && unit.id < 2000) {
                        if (!possibleTargets.includes(unit.id)) {
                            if (debug) {console.log('in this, for the enemy visible tile, it detected a player unit: ', findInUnitsByGridCoordinates(b,a))}
                            possibleTargets.push(unit);
                        }
                    }
                }
            }
        }

        return possibleTargets;
    }

    function updateEnemyTargets() {
        var unitsWithoutTargets = [];
        var totalUnits = 0;

        // fill array with unassigned units and while at it keep a count of total enemy units
        for (var enemyUnit = 0; enemyUnit < units.length; enemyUnit ++) {
            if (units[enemyUnit].id >= 2000) {
                totalUnits ++;

                if (units[enemyUnit].target === null) {
                    unitsWithoutTargets.push(units[enemyUnit])
                }
            }
        }

        // see if there are less units with targets than there should be (according to its defense parameter)
        var possibleTargets = getAllVisibleTargets();

        if (possibleTargets.length > 0) {
            if (debug) {console.log('I need more targets, I can choose from: ', possibleTargets)}

            var possibleTargetsForUnits = [];
            // loop through all 'idle' units
            for (var a = 0; a < unitsWithoutTargets.length; a++) {
                // loop through all possible targets and store the shortest path to it, for this unit, into the possibleTargetsForUnits array
                for (var b = 0; b < possibleTargets.length; b++) {
                    var tempPath = getPathForUnitPositions(unitsWithoutTargets[a].gridX, unitsWithoutTargets[a].gridY, possibleTargets[b].gridX, possibleTargets[b].gridY, true);
                    // ensure path is valid
                    if (tempPath && tempPath.length > 0) {
                        // adding path for this enemy unit to a target to the possibleTargetsForUnits array
                        possibleTargetsForUnits.push({
                            unit: unitsWithoutTargets[a],
                            target: possibleTargets[b],
                            path: tempPath
                        });
                    }
                }
            }
            if (debug) {console.log('constructed collection of targets and paths for each enemy unit: ', possibleTargetsForUnits)}

            if (possibleTargetsForUnits.length > 0) {
                // of all saved paths, simply take the shortest one and set its corresponding unit.id as a target for the corresponding unit
                var shortestPath = possibleTargetsForUnits[0]; // take the first one to test the other paths against

                for (var c = 0; c < possibleTargetsForUnits.length; c++) {
                    if (possibleTargetsForUnits[c].path.length < possibleTargetsForUnits[c].unit.range) {
                        // if the path is shorter than the shooting distance (range) for the unit, set its target
                        // and simply continue with the next. this is done to ensure the enemy will always defend itself
                        // when you run in front of them, or when they spot you during exploring
                        possibleTargetsForUnits[c].unit.target = possibleTargetsForUnits[c].target.id;
                    } else {
                        // if this path is shorter than the one that was stored before, replace it
                        if (possibleTargetsForUnits[c].path.length < shortestPath.path.length) {
                            shortestPath = possibleTargetsForUnits[c];
                        }
                    }
                }

                if (debug) {console.log('found the shortest path to a target for one of the enemy units: ', shortestPath)}

                if ((totalUnits - unitsWithoutTargets.length) < parseInt(enemyOffense * totalUnits)) {
                    // checking whether new target should be set is purposely done at the end of the loop to ensure the
                    // defense mechanism is triggered. otherwise you'd have to do the loop twice. also, do one at a time
                    // since this game is simulating someone playing it, not actual tanks and battlefields and such.
                    shortestPath.unit.target = shortestPath.target.id;
                }
            }
        } else {
            if (debug) {console.log('I dont have targets and depending on my exploration parameter I am going to look around for some')}
            // todo: can parts of the code below be leveraged for the random positions at the game start?

            var unitsWithoutTargetsOrDestinations = [];
            // loop through the unitsWithoutTargets array and check whether the unit has a gridDestX, gridDestY. if not add to unitsWithoutTargetsOrDestinations array
            for (var a = 0; a < unitsWithoutTargets.length; a++) {
                if (unitsWithoutTargets[a].gridDestX === null) {
                    unitsWithoutTargetsOrDestinations.push(unitsWithoutTargets[a]);
                }
            }

            if (unitsWithoutTargetsOrDestinations.length > 0 && (parseInt(enemyExploration * unitsWithoutTargetsOrDestinations.length) > 0)) {
                // find an unexplored spot on the map
                var newY = parseInt(enemyShadowMap.length * Math.random());
                var newX = parseInt(enemyShadowMap[0].length * Math.random());

                while (map[newY][newX] === 1 || findInUnitsByGridCoordinates(newX, newY) || newY < rangeY || newX < rangeX || newY > (map.length - rangeY) || newX > (map[0].length - rangeX)) {
                    newY = parseInt(enemyShadowMap.length * Math.random());
                    newX = parseInt(enemyShadowMap[0].length * Math.random());
                }

                if (debug) {console.log('found coordinates that are not visible yet, but are valid to move to according to the map and units: ', newX, newY)} // yeah, it cheats a bit to be more efficient.

                // pick a random idle unit and send it off to these coordinates
                var randomUnit = parseInt(Math.random() * unitsWithoutTargetsOrDestinations.length);

                if (parseInt(Math.random() * 10) === 1) {playSound('assets/sound-whereareyou.mp3')}

                moveUnitToPosition(unitsWithoutTargetsOrDestinations[randomUnit].id, newX, newY);
            }
        }
    }

    function updateEdgeScroller() {
        if (edgeScrolling) {
            if (posX+scrollDirX > rangeX && posX+scrollDirX < (map[0].length - rangeX)) {posX += scrollDirX}
            if (posY+scrollDirY > rangeY && posY+scrollDirY < (map.length - rangeY)) {posY += scrollDirY}
        }
    }

    function updateCanvas() {
        clearCanvas();

        if (assetsLoaded) {
            // this is controlled by autoCenter flag. not sure if going to keep since it is not very smooth
            if (!edgeScrollingFlag && selectedUnits.length === 1) {
                // if a single unit is selected and the current view positions are different, update them (follow mode)
                if (posX !== findUnitById(selectedUnits[0]).gridX || posY !== findUnitById(selectedUnits[0]).gridY) {
                    edgeScrollingFlag = false;
                    if (autoCenter) {
                        posX = findUnitById(selectedUnits[0]).gridX;
                        posY = findUnitById(selectedUnits[0]).gridY;
                    }
                }
            }

            drawMapSelection();
            updateUnitCoordinates();
            drawUnitsInMapSelection();

            // edge scrolling and its timer
            if (Date.now() - 100 > edgeScrollingTimer) {
                edgeScrollingTimer = Date.now();
                if (edgeScrolling) {
                    updateEdgeScroller()
                }
            }

            if (Date.now() - 2000 > waterVariationTimer) {
                waterVariationTimer = Date.now();
                // looping through all 1-s in the map and replacing some with 8-s. likewise, all existing 8-s are back to 1 again
                for (var a = 0; a < map.length; a++) {
                    for (var b = 0; b < map[a].length; b++) {
                        if (map[a][b] === 8) {
                            map[a][b] = 1;
                        }
                        if (map[a][b] === 1 && (parseInt(Math.random() * 250) === 1)) {
                            map[a][b] = 8;
                        }
                    }
                }

                // abusing this 2 second timeout to efficiently search for newly spotted enemies in the revealed parts of the map
                updateSpottedEnemies();
            }

            if (Date.now() - enemySpeedForCheckingUnits > oldEnemyCheckTimer) {
                oldEnemyCheckTimer = Date.now();
                updateEnemyTargets();
            }
        } else {
            if (areAllImageAssetsLoaded()) {
                context.font = "30px Trebuchet MS";
                context.fillStyle = "#fff";
                context.fillText("LOADING", (850 / 2) - (context.measureText("LOADING").width / 2), 250);
                context.font = "14px Trebuchet MS";
                context.fillStyle = "#888";
                context.fillText("sound data", (850 / 2) - (context.measureText("sound data").width / 2), 280);
                if (document.getElementById('music-level-1').readyState) {
                    assetsLoaded = true;

                    if (soundEffects) {
                        document.getElementById('music-level-1').play();
                    }
                }
            } else {
                context.font = "30px Trebuchet MS";
                context.fillStyle = "#fff";
                context.fillText("LOADING", (850 / 2) - (context.measureText("LOADING").width / 2), 250);
                context.font = "14px Trebuchet MS";
                context.fillStyle = "#888";
                context.fillText(loadingAsset, (850 / 2) - (context.measureText(loadingAsset).width / 2), 280);
            }
        }

        // set interval in ms
        setTimeout(updateCanvas, 50);
    }

    function clearCanvas() {
        context.fillStyle = '#000';
        context.fillRect(0, 0, 850, 650);
    }
</script>

</body>
</html>
