<!DOCTYPE html>
<html lang="en">
<head>
    <title>RTS 2</title>
    <style>
        body {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            font-size: 16px;
        }

        .wrapper {
            width: auto;
            max-width: 850px;
            margin: auto;
        }
        @media screen and (min-width: 1024px) {
            .wrapper {
                width: 850px;
                max-width: unset;
            }
        }
        .canvas-container {
            height: auto;
            max-height: 850px;
            width: 100%;
            box-sizing: border-box;
            border: 0;
            margin-top: 0;
            background: #000;
            box-shadow: none;
        }
        @media screen and (min-width: 1024px) {
            .canvas-container {
                margin-top: 20px;
                display: inline-block;
                box-sizing: content-box;
            }
        }
        canvas {
            image-rendering: optimizeSpeed;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: -o-crisp-edges;
            image-rendering: pixelated;
            -ms-interpolation-mode: nearest-neighbor;
        }
        #canvas {
            width: 100%;
            max-width: 850px;
            box-sizing: border-box;
            display: block;
            margin: 0 auto;
            background: #000;
        }
    </style>
</head>
<body>

<div class="wrapper">
    <div class="canvas-container" id="canvas-container">
        <canvas id="canvas" width="850" height="650">Oh no! Canvas is not supported on your device :(</canvas>
    </div>
</div>

<script type="text/javascript" src="pathfinding-browser.min.js"></script>

<script>
    // register global window event listener for click events
    window.addEventListener('click', clickHandler);
    window.addEventListener('mousemove', hoverHandler);

    // declare some vars
    var context = document.getElementById('canvas').getContext('2d');

    // define tile map for scenery (always have 1's surrounding the 'playfield', 6 vertically, 8 horizontally)
    var map = [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 5, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 2, 5, 1, 1, 1, 5, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 2, 5, 1, 5, 5, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 2, 5, 1, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 2, 5, 1, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 2, 5, 1, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 2, 2, 5, 1, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 5, 5, 2, 2, 5, 1, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 5, 5, 2, 2, 5, 1, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 2, 2, 2, 2, 2, 2, 2, 2, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 5, 5, 2, 2, 5, 6, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 5, 5, 5, 5, 2, 2, 2, 2, 2, 2, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 2, 5, 1, 5, 5, 2, 2, 2, 2, 2, 2, 2, 5, 5, 5, 5, 5, 5, 5, 5, 2, 2, 2, 2, 2, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 5, 5, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 2, 2, 5, 5, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1, 1, 1, 1, 1 ,1 ,1 ,1 ,1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ];

    var bitmaps = [
        {
            id: 'grass',
            src: 'assets/tile-grass.png',
            img: new Image()
        },
        {
            id: 'water',
            src: 'assets/tile-water.png',
            img: new Image()
        },
        {
            id: 'tank',
            src: 'assets/tile-tank.png',
            img: new Image()
        },
        {
            id: 'tree',
            src: 'assets/tile-tree.png',
            img: new Image()
        },
        {
            id: 'sand',
            src: 'assets/tile-sand.png',
            img: new Image()
        },
        {
            id: 'bridge',
            src: 'assets/tile-bridge.png',
            img: new Image()
        },
        {
            id: 'tank-selected',
            src: 'assets/tile-tank-selected.png',
            img: new Image()
        }
    ];

    function loadBitmap(bitmap) {
        // load the image assets by setting bitmap.img.src to bitmap.src
        bitmap['img'].src = bitmap['src']
    }

    // load images
    for(var bitmap=0;bitmap<bitmaps.length;bitmap++){
        loadBitmap(bitmaps[bitmap])
    }

    function allAssetsLoaded() {
        for (bitmap=0;bitmap<bitmaps.length;bitmap++) {
            if (bitmap.img.naturalWidth === 0) {
                return false;
            }
        }

        return true;
    }

    // define map to keep track of units. this is only used for the user clicking around and assigning actions and
    // targets and is updated every time a unit changes grid position (reached destination, starts moving)
//    var unitMap = [];
//    // initially fill with zeroes based on the scenery tile map
//    for (var a = 0; a < map.length; a++) {
//        var tempUnitMap = [];
//        for (var b = 0; b < map[a].length; b++) {
//            tempUnitMap.push(0);
//        }
//        unitMap.push(tempUnitMap);
//    }


    // collection of objects describing all units in the game (should I use class instantiation for this?)
    var units = [
        {
            id: 1000,
            unitType: 4,
            x: 450,
            y: 450,
            rotation: 0,
            gridX: 9,
            gridY: 9,
            gridDestX: null,
            gridDestY: null,
            gridSubDestX: null,
            gridSubDestY: null,
            path: [],
            target: null,
            speed: 5,
            health: 100
        },
        {
            id: 1001,
            unitType: 4,
            x: 750,
            y: 450,
            rotation: 0,
            gridX: 15,
            gridY: 9,
            gridDestX: null,
            gridDestY: null,
            gridSubDestX: null,
            gridSubDestY: null,
            path: [],
            target: null,
            speed: 5,
            health: 100
        },
        {
            id: 100,
            unitType: 100,
            x: 850,
            y: 450,
            gridX: 17,
            gridY: 9,
            health: 100
        },
        {
            id: 100,
            unitType: 100,
            x: 900,
            y: 450,
            gridX: 18,
            gridY: 9,
            health: 100
        },
        {
            id: 100,
            unitType: 100,
            x: 850,
            y: 500,
            gridX: 17,
            gridY: 10,
            health: 100
        }
    ];

    // keeps track of units selected by the user. much faster than querying units array.
    var selectedUnits = [];

    // determines how many tiles visible on screen, max offset from edge, and starting position of map.
    var rangeX = 8;
    var rangeY = 6;

    // map start position (do not make it lower than rangeX, rangeY or higher than array size - range)
    var posX = rangeX;
    var posY = rangeY;

    // dimensions of tile
    tileWidth = 50;
    tileHeight = 50;

    // set some vars to facilitate edge scrolling
    var oldtimer = 0;
    var edgeScrolling = false;
    var scrollDirX = 0;
    var scrollDirY = 0;

    // this is fed to the pathfinding function and consists of all scenery tiles (= true) and unit tiles (= false)
    // var grid = []; // todo: rename
    //var grid = [];
    // todo: ensure this only triggers after units have fully moved to a new tile
    // create empty grid
    var grid = createPathfindingGrid();

    var finder = new PF.AStarFinder();
    var path;

    // trigger update function
    updateCanvas();
    updateEdgeScroller();

    /***************************** functions *******************************/

    function clickHandler(event) {
        // todo: handler does not take scaling into account

        // make sure only the canvas is targeted
        var offsetLeft = document.getElementById("canvas").offsetLeft;
        var offsetTop = document.getElementById("canvas").offsetTop;

        // get clicked coords relative to grid
        var mouseX = event.clientX - offsetLeft;
        var mouseY = event.clientY - offsetTop;

        // ensure user clicked within bounds
        if(mouseX < 0 || mouseX > 850 || mouseY < 0 || mouseY > 650) {
            console.log('out of bounds');
        } else {
            // get value of grid that is at that position
            var gridX = Math.floor(mouseX / tileWidth);
            var gridY = Math.floor(mouseY / tileHeight);

            var newX, newY;

            // depending on whether player clicked right, left, up or down from center, calculate new map index
            if (gridX > rangeX) {
                newX = posX + (gridX - rangeX);
            } else {
                newX = posX - (rangeX - gridX);
            }
            if (gridY > rangeY) {
                newY = posY + (gridY - rangeY);
            } else {
                newY = posY - (rangeY - gridY);
            }

            // see if a unit lives at that position
            if(!grid.isWalkableAt(newX, newY)){
                // something is there. is it a unit?
                var unit = findInUnitsByGridCoordinates(newX, newY);

                if(unit) {
                    // deselect all units (wont work when implementing attack targets, but okay for now)
                    selectedUnits = [];
                    // add the unit
                    selectedUnits.push(unit.id);
                } else {
                    // not a unit. move map.
                    setNewMapCoordinates(newX, newY);
                }

            } else {
                // this tile is walkable. so either move a selected unit there, or move the map selection
                // if a unit was already selected, set its target coordinates to the newX, newY
                if (map[newY][newX] !== 1 && selectedUnits.length > 0) {
                    // move selected units
                    for (var a = 0; a < selectedUnits.length; a++) {
                        var selectedUnitId = selectedUnits[a];
                        // console.log('moving unit '+selectedUnitId+' to coordinates '+newX+','+newY+' which has id '+map[newY][newX]);
                        moveUnitToPosition(selectedUnitId, newX, newY);
                        // deselect the unit (this seems UI-wise to be best)
                        selectedUnits = [];
                    }
                } else {
                    // move the view to the new location
                    setNewMapCoordinates(newX, newY);
                }
            }

        }
    }

    function setNewMapCoordinates(x, y) {
        posX = x;
        posY = y;

        // magic corrections (determines how much the map is allowed to move out of view. 8 for x, 6 for y)
        // todo: refactor to use rangeX, rangeY units
        if (posX < rangeX) {
            posX = rangeX
        }
        if (posX > (map[0].length - 9)) {
            posX = (map[0].length - 9)
        }
        if (posY < rangeY) {
            posY = rangeY
        }
        if (posY > (map.length - 7)) {
            posY = (map.length - 7)
        }
    }

    function hoverHandler(event) {
        // make sure only the canvas is targeted
        var offsetLeft = document.getElementById("canvas").offsetLeft;
        var offsetTop = document.getElementById("canvas").offsetTop;

        // get clicked coords relative to grid
        var mouseX = event.clientX - offsetLeft;
        var mouseY = event.clientY - offsetTop;

        if((mouseY > 650 ) || (mouseX > 850) || (mouseX < 0 || (mouseX > 50 && mouseX < 800)) && (mouseY < 0 || (mouseY > 50 && mouseY < 600))) {
            edgeScrolling = false;
        } else {
            edgeScrolling = true;
            scrollDirX = 0;
            scrollDirY = 0;
            if     (mouseY < 50  && mouseX > 800){scrollDirX++;scrollDirY--}
            else if(mouseY > 600 && mouseX > 800){scrollDirX++;scrollDirY++}
            else if(mouseY <  50 && mouseX < 50){scrollDirX--;scrollDirY--}
            else if(mouseY > 600 && mouseX < 50){scrollDirX--;scrollDirY++}
            else if(mouseX > 800){scrollDirX++}
            else if(mouseX < 50){scrollDirX--}
            else if(mouseY > 600){scrollDirY++}
            else if(mouseY < 50){scrollDirY--}
            else {/* no idea what user wants */}
        }
    }

    function createPathfindingGrid() {
        grid = new PF.Grid(map[0].length, map.length);

        // scenery (static)
        for(var a=0;a<map.length;a++){
            for(var b=0;b<map[a].length;b++){
                if(map[a][b] === 1) {
                    // found non-walkable tile
                    grid.setWalkableAt(b, a, false);
                }
            }
        }

        // units (including grid destination coordinates)
        for(var c=0;c<units.length;c++) {
            // current unit grid position
            var x = units[c].gridX;
            var y = units[c].gridY;
            grid.setWalkableAt(x, y, false);
            // destination grid position
            if(units[c].gridSubDestX && units[c].gridSubDestY) {
                var x2 = units[c].gridSubDestX;
                var y2 = units[c].gridSubDestY;
                grid.setWalkableAt(x2, y2, false);
            }
        }

        return grid;
    }

    function findInSelectedUnitsById(id) {
        for(var a=0;a<selectedUnits.length;a++){
            if(selectedUnits[a] === id) {
                return true;
            }
        }

        return false;
    }

    function findInUnitsByGridCoordinates(x,y) {
        for(var a=0;a<units.length;a++){
            if(x === units[a].gridX && y === units[a].gridY && units[a].id >= 1000) {
                return units[a];
            }
        }

        return false;
    }

    function drawMapSelection() {
        if(allAssetsLoaded) {
            // draw all grid units that are within view
            for (var row = 0; row <= (2 * rangeY); row++) {
                var tileY = posY - (rangeY); // range is -6 to 6 with 0 being middle or equal to posY
                tileY += row;
                for (var col = 0; col <= (2 * rangeX); col++) {
                    var tileX = posX - (rangeX);
                    tileX += col;
                    drawBackgroundTile(col * tileWidth, row * tileHeight, map[tileY][tileX]);
                }
            }
        }
    }

    function getBitmapForTileType(tileType, id = null) {
        switch(tileType){
            case 1: return findObjectInArrayById('water');
            case 2: return findObjectInArrayById('grass');
            case 100: return findObjectInArrayById('tree');
            case 4: if(findInSelectedUnitsById(id)){return findObjectInArrayById('tank-selected')}else{return findObjectInArrayById('tank')}
            case 5: return findObjectInArrayById('sand');
            case 6: return findObjectInArrayById('bridge');
            case 7: return findObjectInArrayById('tank-selected');
            default: console.log('unknown tileType provided');return false;
        }
    }

    function findObjectInArrayById(id){
        for(var imageObject=0;imageObject<bitmaps.length;imageObject++){
            if (bitmaps[imageObject]['id'] === id) {
                return bitmaps[imageObject];
            }
        }
    }

    function drawBackgroundTile(x,y,tileType) {
        var imageId = getBitmapForTileType(tileType);
        context.drawImage(imageId['img'], x, y);
    }

    function moveUnitToPosition(unitId, newGridX, newGridY){
        // simply saves new grid position for a unit
        for(var c=0;c<units.length;c++) {
            if(units[c].id === unitId) {
                units[c].gridDestX = newGridX;
                units[c].gridDestY = newGridY;
            }
        }
    }

    function drawUnit(x,y,unit) {
        // note that the given x,y are already adjusted to fit the current view
        var imageId = getBitmapForTileType(unit.unitType, unit.id);
        context.drawImage(imageId['img'], x, y);
    }

    function drawUnitsInMapSelection(){
        for(var a=0;a<units.length;a++){
            // calculate relative x,y
            var relX = units[a].x - ((posX-8) * tileWidth);
            var relY = units[a].y - ((posY-6) * tileHeight);
            if(relX>=0 && relX<850 && relY>=0 && relY <650){
                // if in view, draw the unit
                drawUnit(relX,relY,units[a]);
            }
        }
    }

    function getPathForUnitPositions(x,y,newx,newy) {
        // you need to reinstantiate the grid for each call! see https://github.com/qiao/PathFinding.js/issues/109
        grid = createPathfindingGrid();

        grid.setWalkableAt(x, y, true);
        var pathOutput = finder.findPath(x, y, newx, newy, grid);
        grid.setWalkableAt(x, y, false);
        return pathOutput;
    }

    function updateUnitCoordinates() {
        for(var c=0;c<units.length;c++) {
            var unit = units[c];
            var x = unit.x;
            var y = unit.y;

            // is unit movable (id>1000) and does it have a target?
            if (unit.id >= 1000 && unit.gridDestX && unit.gridDestY) {
                // is there a subtarget set?
                if (unit.gridSubDestX && unit.gridSubDestY) {
                    // is subtarget reached?
                    if (unit.gridX === unit.gridSubDestX && unit.gridY === unit.gridSubDestY) {
                        // console.log('reached sub destination ' + unit.gridSubDestX + ',' + unit.gridSubDestY);
                        unit.gridSubDestX = null;
                        unit.gridSubDestY = null;
                        // is final target reached?
                        if (unit.gridX === unit.gridDestX && unit.gridY === unit.gridDestY) {
                            // reached final destination
                            // console.log('reached final destination ' + unit.gridDestX + ',' + unit.gridDestY);
                            unit.path = [];
                            unit.gridSubDestX = null;
                            unit.gridSubDestY = null;
                            unit.gridDestX = null;
                            unit.gridDestY = null;
                        } else {
                            // recalculate path
                            unit.path = getPathForUnitPositions(unit.gridX, unit.gridY, unit.gridDestX, unit.gridDestY);
                            // take the first entry off the path (actually the second, first one is current position)
                            if(unit.path.length >= 2) {
                                unit.gridSubDestX = unit.path[1][0];
                                unit.gridSubDestY = unit.path[1][1];
                                // todo: reserve the destination tile (isnt this done in the grid creation function? check it)
                            } else {
                                // path is blocked off by some other unit or incorrectly calculated
                            }
                        }
                    } else {
                        // not there yet. calculate translation for x, y (depending on orientation also)
                        if (unit.gridSubDestX < unit.gridX) {
                            //  todo: refactor this whole bit. its possible.
                            x -= unit.speed;
                            unit.rotation = 90;
                            // ensure it doesnt move past its destination
                            if (x <= ((unit.gridX - 1) * tileWidth)) {
                                x = ((unit.gridX - 1) * tileWidth);
                                // just before changing grid position for this unit, update the grid with a walkable = true at the old position
                                grid.setWalkableAt(unit.gridX,unit.gridY, true);
                                unit.gridX--;
                                grid.setWalkableAt(unit.gridX,unit.gridY, false); // and reserve the new tile
                            }
                        }
                        else if (unit.gridSubDestX > unit.gridX) {
                            x += unit.speed;
                            unit.rotation = 90;
                            // ensure it doesnt move past its destination
                            if (x >= ((unit.gridX + 1) * tileWidth)) {
                                x = ((unit.gridX + 1) * tileWidth);
                                // just before changing grid position for this unit, update the grid with a walkable = true at the old position
                                grid.setWalkableAt(unit.gridX,unit.gridY, true);
                                unit.gridX++;
                                grid.setWalkableAt(unit.gridX,unit.gridY, false); // and reserve the new tile
                            }
                        }
                        else if (unit.gridSubDestY < unit.gridY) {
                            y -= unit.speed;
                            unit.rotation = 90;
                            // ensure it doesnt move past its destination
                            if (y <= ((unit.gridY - 1) * tileWidth)) {
                                y = ((unit.gridY - 1) * tileHeight);
                                // just before changing grid position for this unit, update the grid with a walkable = true at the old position
                                grid.setWalkableAt(unit.gridX,unit.gridY, true);
                                unit.gridY--;
                                grid.setWalkableAt(unit.gridX,unit.gridY, false); // and reserve the new tile
                            }
                        }
                        else if (unit.gridSubDestY > unit.gridY) {
                            y += unit.speed;
                            unit.rotation = 90;
                            // ensure it doesnt move past its destination
                            if (y >= ((unit.gridY + 1) * tileHeight)) {
                                y = ((unit.gridY + 1) * tileHeight);
                                // just before changing grid position for this unit, update the grid with a walkable = true at the old position
                                grid.setWalkableAt(unit.gridX,unit.gridY, true);
                                unit.gridY++;
                                grid.setWalkableAt(unit.gridX,unit.gridY, false); // and reserve the new tile
                            }
                        }
                    }
                } else {
                    unit.path = getPathForUnitPositions(unit.gridX, unit.gridY, unit.gridDestX, unit.gridDestY);
                    if(unit.path.length > 1) {
                        unit.gridSubDestX = unit.path[1][0];
                        unit.gridSubDestY = unit.path[1][1];
                    } else {
                        // cannot move right now due to blocking. will move eventually (or implement a timeout?)
                    }
                }
            } else {
                // no target set for this unit, nothing to do here
            }

            // update x,y for this unit
            unit.x = x;
            unit.y = y;
        }
    }

    function updateEdgeScroller() {
        if(edgeScrolling) {
            if(posX+scrollDirX > rangeX && posX+scrollDirX < (map[0].length-rangeX)) {posX += scrollDirX}
            if(posY+scrollDirY > rangeY && posY+scrollDirY < (map.length-rangeY)) {posY += scrollDirY}
        }
    }

    function updateCanvas() {
        clearCanvas();
        drawMapSelection();
        updateUnitCoordinates();
        drawUnitsInMapSelection();

        // edge scrolling and its timer
        if(Date.now()-100 > oldtimer) {
            oldtimer = Date.now();
            if (edgeScrolling) {
                updateEdgeScroller()
            }
        }

        // set interval
        setTimeout(updateCanvas, 50);
    }

    function clearCanvas() {
        context.fillStyle = '#000';
        context.fillRect(0, 0, 850, 650);
    }
</script>

</body>
</html>
